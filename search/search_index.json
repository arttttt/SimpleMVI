{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p>A lightweight, flexible, and powerful MVI library for Kotlin Multiplatform applications. It's built on top of the KMM technology</p>"},{"location":"#supported-platforms","title":"Supported platforms","text":"<ul> <li>Android</li> <li>iOS</li> <li>macOS</li> <li>wasm js</li> </ul> <p>Additional supported platforms will be added in the future</p>"},{"location":"actor/actor/","title":"Actor","text":"<p>The <code>Actor</code> is a crucial component of the <code>Store</code> architecture, responsible for implementing the core logic of the application.</p>"},{"location":"actor/actor/#overview","title":"Overview","text":"<p><code>Actor</code> is designed to:</p> <ul> <li>Accept <code>Intent</code></li> <li>Produce <code>SideEffect</code></li> <li>Generate new <code>State</code></li> </ul> <p>It must be part of the <code>Store</code> and is managed by it.</p>"},{"location":"actor/actor/#interface-definition","title":"Interface Definition","text":"<pre><code>public interface Actor&lt;Intent : Any, State : Any, out SideEffect : Any&gt; {\n\n    /**\n     * Initializes the Actor\n     * Called by the Store\n     */\n    public fun init(\n        scope: CoroutineScope,\n        getState: () -&gt; State,\n        reduce: (State.() -&gt; State) -&gt; Unit,\n        onNewIntent: (Intent) -&gt; Unit,\n        postSideEffect: (sideEffect: SideEffect) -&gt; Unit,\n    )\n\n    /**\n     * Called when the Store receives a new Intent\n     * Called by the Store\n     */\n    public fun onIntent(intent: Intent)\n\n    /**\n     * Destroys the Actor\n     * Called by the Store\n     */\n    public fun destroy()\n}\n</code></pre>"},{"location":"actor/actor/#key-methods","title":"Key Methods","text":""},{"location":"actor/actor/#init","title":"init","text":"<pre><code>public fun init(\n    scope: CoroutineScope,\n    getState: () -&gt; State,\n    reduce: (State.() -&gt; State) -&gt; Unit,\n    onNewIntent: (Intent) -&gt; Unit,\n    postSideEffect: (sideEffect: SideEffect) -&gt; Unit,\n)\n</code></pre> <p>This function initializes the <code>Actor</code>. It is called by the <code>Store</code> and provides the <code>Actor</code> with necessary dependencies:</p> <ul> <li><code>scope</code>: A <code>CoroutineScope</code> for managing coroutines</li> <li><code>getState</code>: A function to retrieve the current state</li> <li><code>reduce</code>: A function to update the state</li> <li><code>onNewIntent</code>: A function to handle new intents</li> <li><code>postSideEffect</code>: A function to emit side effects</li> </ul>"},{"location":"actor/actor/#onintent","title":"onIntent","text":"<pre><code>public fun onIntent(intent: Intent)\n</code></pre> <p>This function is called when the <code>Store</code> receives a new <code>Intent</code>. It's where the <code>Actor</code> processes incoming intents and updates the state or produces side effects accordingly.</p>"},{"location":"actor/actor/#destroy","title":"destroy","text":"<pre><code>public fun destroy()\n</code></pre> <p>This function is called to destroy the <code>Actor</code>. It should be used to clean up any resources or cancel any ongoing operations.</p>"},{"location":"actor/actor/#actor-implementations","title":"Actor Implementations","text":"<p>SimpleMVI provides three approaches for implementing actors:</p>"},{"location":"actor/actor/#1-defaultactor-object-oriented-approach","title":"1. DefaultActor - Object-Oriented Approach","text":"<p><code>DefaultActor</code> is an abstract base class that provides a traditional OOP approach to implementing actors:</p> <pre><code>class CounterActor : DefaultActor&lt;CounterIntent, CounterState, CounterSideEffect&gt;() {\n\n    override fun handleIntent(intent: CounterIntent) {\n        when (intent) {\n            is CounterIntent.Increment -&gt; {\n                reduce { copy(count = count + 1) }\n            }\n            is CounterIntent.Decrement -&gt; {\n                reduce { copy(count = count - 1) }\n            }\n            is CounterIntent.Reset -&gt; {\n                reduce { CounterState() }\n                sideEffect(CounterSideEffect.CounterReset)\n            }\n        }\n    }\n\n    override fun onInit() {\n        // Optional: initialization logic\n    }\n\n    override fun onDestroy() {\n        // Optional: cleanup logic\n    }\n}\n</code></pre> <p>Available protected members:</p> <ul> <li><code>state: State</code> - Access to current state</li> <li><code>scope: CoroutineScope</code> - Coroutine scope for async operations</li> <li><code>reduce(block: State.() -&gt; State)</code> - Update state</li> <li><code>sideEffect(sideEffect: SideEffect)</code> - Emit side effect</li> <li><code>intent(intent: Intent)</code> - Dispatch new intent</li> </ul> <p>When to use:</p> <ul> <li>Complex business logic requiring shared state or helper methods</li> <li>Large projects where OOP structure is beneficial</li> <li>When you prefer traditional class-based approach</li> <li>When you need to share logic between multiple intent handlers</li> </ul>"},{"location":"actor/actor/#2-actordsl-functional-dsl-approach","title":"2. actorDsl - Functional DSL Approach","text":"<p>The <code>actorDsl</code> function provides a declarative DSL for creating actors without defining a class:</p> <pre><code>val counterActor = actorDsl&lt;CounterIntent, CounterState, CounterSideEffect&gt; {\n    onInit {\n        // Optional: initialization logic\n    }\n\n    onIntent&lt;CounterIntent.Increment&gt; { intent -&gt;\n        reduce { copy(count = count + 1) }\n    }\n\n    onIntent&lt;CounterIntent.Decrement&gt; { intent -&gt;\n        reduce { copy(count = count - 1) }\n    }\n\n    onIntent&lt;CounterIntent.Reset&gt; { intent -&gt;\n        reduce { CounterState() }\n        sideEffect(CounterSideEffect.CounterReset)\n    }\n\n    onDestroy {\n        // Optional: cleanup logic\n    }\n}\n</code></pre> <p>Features:</p> <ul> <li>Type-safe intent handling using reified types</li> <li>Each intent type can have only one handler</li> <li>Handlers execute in the context of <code>ActorScope</code></li> <li>Less boilerplate code</li> <li>Declarative style</li> </ul> <p>When to use:</p> <ul> <li>Small to medium-sized projects</li> <li>Simple business logic without complex dependencies</li> <li>When you prefer functional style</li> <li>Prototyping and quick development</li> </ul>"},{"location":"actor/actor/#3-delegatedactor-explicit-handler-composition","title":"3. delegatedActor - Explicit Handler Composition","text":"<p>The <code>delegatedActor</code> function allows you to explicitly compose intent handlers, providing maximum flexibility:</p> <pre><code>val counterActor = delegatedActor&lt;CounterIntent, CounterState, CounterSideEffect&gt;(\n    initHandler = InitHandler {\n        // Optional: initialization logic\n    },\n    intentHandlers = listOf(\n        intentHandler&lt;CounterIntent, CounterState, CounterSideEffect, CounterIntent.Increment&gt; { intent -&gt;\n            reduce { copy(count = count + 1) }\n        },\n        intentHandler&lt;CounterIntent, CounterState, CounterSideEffect, CounterIntent.Decrement&gt; { intent -&gt;\n            reduce { copy(count = count - 1) }\n        },\n        intentHandler&lt;CounterIntent, CounterState, CounterSideEffect, CounterIntent.Reset&gt; { intent -&gt;\n            reduce { CounterState() }\n            sideEffect(CounterSideEffect.CounterReset)\n        }\n    ),\n    destroyHandler = DestroyHandler {\n        // Optional: cleanup logic\n    }\n)\n</code></pre> <p>Features:</p> <ul> <li>Explicit handler registration</li> <li>Handlers can be defined separately and composed</li> <li>Useful for modular code organization</li> <li>Can be combined with code generation (see below)</li> </ul> <p>When to use:</p> <ul> <li>When you need to compose handlers from different modules</li> <li>When handlers are defined separately</li> <li>When using code generation for intent handlers</li> <li>Large projects with complex handler composition</li> </ul>"},{"location":"actor/actor/#code-generation-for-delegatedactor","title":"Code Generation for DelegatedActor","text":"<p>SimpleMVI provides KSP-based code generation to simplify working with <code>delegatedActor</code> and intent handlers.</p>"},{"location":"actor/actor/#delegatedstore-annotation","title":"@DelegatedStore Annotation","text":"<p>Annotate your Store with <code>@DelegatedStore</code> to generate type-safe handler factories:</p> <pre><code>@DelegatedStore\nclass CounterStore : Store&lt;CounterStore.Intent, CounterStore.State, CounterStore.SideEffect&gt; by createStore(\n    name = storeName&lt;CounterStore&gt;(),\n    initialState = State(counter = 0),\n    actor = delegatedActor(\n        initHandler = myInitHandler(),\n        intentHandlers = listOf(\n            incrementIntentHandler(),\n            decrementIntentHandler(),\n        ), \n        destroyHandler = myDestroyHandler(),\n    )\n) {\n    sealed interface Intent {\n        data object Increment : Intent\n        data object Decrement : Intent\n    }\n\n    data class State(val counter: Int)\n\n    sealed interface SideEffect {\n        data class CounterChanged(val value: Int) : SideEffect\n        data object Cleanup : SideEffect\n    }\n}\n</code></pre>"},{"location":"actor/actor/#generated-handlers","title":"Generated Handlers","text":"<p>The annotation processor generates factory functions for creating handlers:</p> <pre><code>// counterStoreIntentHandler is a generated function\nfun incrementIntentHandler() = counterStoreIntentHandler&lt;CounterStore.Intent.Increment&gt; { intent -&gt;\n    reduce { copy(counter = counter + 1) }\n    sideEffect(CounterStore.SideEffect.CounterChanged(counter = state.counter))\n}\n\nfun decrementIntentHandler() = counterStoreIntentHandler&lt;CounterStore.Intent.Decrement&gt; { intent -&gt;\n    reduce { copy(counter = counter - 1) }\n    sideEffect(CounterStore.SideEffect.CounterChanged(counter = state.counter))\n}\n</code></pre> <p>Init Handler:</p> <pre><code>// counterStoreInitHandler is a generated function\nfun myInitHandler() = counterStoreInitHandler {\n    reduce { copy(initialized = true) }\n    // Initialization logic\n}\n</code></pre> <p>Destroy Handler:</p> <pre><code>// counterStoreDestroyHandler is a generated function\nfun myDestroyHandler() = counterStoreDestroyHandler {\n    sideEffect(CounterStore.SideEffect.Cleanup)\n    // Cleanup logic\n}\n</code></pre> <p>Benefits:</p> <ul> <li>Type-safe intent handler creation</li> <li>Type-safe lifecycle handler creation</li> <li>Less boilerplate code</li> <li>Better code organization</li> <li>Compile-time safety</li> </ul> <p>Setup:</p> <p>Add the code generation dependency to your build file:</p> <pre><code>// build.gradle.kts\nplugins {\n    id(\"com.google.devtools.ksp\") version \"&lt;version&gt;\"\n}\n\ndependencies {\n    implementation(\"io.github.arttttt.simplemvi:simplemvi:&lt;version&gt;\")\n    implementation(\"io.github.arttttt.simplemvi:simplemvi-annotations:&lt;version&gt;\")\n    ksp(\"io.github.arttttt.simplemvi:simplemvi-codegen:&lt;version&gt;\")\n}\n</code></pre>"},{"location":"actor/actor/#actorscope","title":"ActorScope","text":"<p>All actor implementations provide access to <code>ActorScope</code>, which offers:</p> <pre><code>interface ActorScope&lt;in Intent : Any, State : Any, in SideEffect : Any&gt; {\n    val state: State                          // Current state\n    val scope: CoroutineScope                 // Coroutine scope for async work\n\n    fun reduce(block: State.() -&gt; State)      // Update state\n    fun sideEffect(sideEffect: SideEffect)    // Emit side effect\n    fun intent(intent: Intent)                // Dispatch new intent\n}\n</code></pre> <p>For detailed information about ActorScope, see the ActorScope documentation.</p>"},{"location":"actor/actor/#example-async-operations","title":"Example: Async Operations","text":"<p>Async operations in actors:</p> <pre><code>class DataActor : DefaultActor&lt;DataIntent, DataState, DataSideEffect&gt;() {\n\n    override fun handleIntent(intent: DataIntent) {\n        when (intent) {\n            is DataIntent.LoadData -&gt; {\n                reduce { copy(loading = true) }\n\n                scope.launch {\n                    try {\n                        val data = repository.fetchData()\n                        reduce { copy(loading = false, data = data) }\n                        sideEffect(DataSideEffect.DataLoadSucceeded)\n                    } catch (e: Exception) {\n                        reduce { copy(loading = false, error = e.message) }\n                        sideEffect(DataSideEffect.DataLoadFailed(e.message ?: \"Unknown error\"))\n                    }\n                }\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"actor/actor/#choosing-the-right-approach","title":"Choosing the Right Approach","text":"Approach Best For Pros Cons DefaultActor Complex logic, large projects OOP structure, shared helpers More boilerplate actorDsl Simple logic, quick development Concise, declarative Less structure for complex cases delegatedActor Modular composition, code generation Flexible handlers More verbose without codegen"},{"location":"actor/actor/#important-notes","title":"Important Notes","text":"<ul> <li>The <code>Actor</code> is tightly coupled with the <code>Store</code> and should not be used independently.</li> <li>Implementations of <code>Actor</code> should handle all business logic, state updates, and side effect production based on received intents.</li> <li>All coroutines launched in the actor's scope are automatically cancelled when the store is destroyed.</li> <li>State updates via <code>reduce</code> should be pure functions without side effects.</li> </ul> <p>For more information on how <code>Actor</code> interacts with other components, refer to the <code>Store</code> and <code>ActorScope</code> documentation.</p>"},{"location":"actor/actorscope/","title":"ActorScope","text":""},{"location":"actor/actorscope/#overview","title":"Overview","text":"<p><code>ActorScope</code> is the execution context provided to all actors (both <code>DefaultActor</code>, <code>actorDsl</code>, and <code>delegatedActor</code>). It provides access to state, coroutine management, and state modification capabilities.</p>"},{"location":"actor/actorscope/#interface-definition","title":"Interface Definition","text":"<pre><code>public interface ActorScope&lt;in Intent : Any, State : Any, in SideEffect : Any&gt; {\n    val state: State\n    val scope: CoroutineScope\n\n    fun intent(intent: Intent)\n    fun reduce(block: State.() -&gt; State)\n    fun sideEffect(sideEffect: SideEffect)\n}\n</code></pre>"},{"location":"actor/actorscope/#properties","title":"Properties","text":""},{"location":"actor/actorscope/#state","title":"state","text":"<p>Type: <code>State</code> (read-only)</p> <p>Provides access to the current state of the store:</p> <pre><code>onIntent&lt;MyIntent.Calculate&gt; { intent -&gt;\n    val currentValue = state.value  // Read current state\n    val newValue = currentValue * 2\n    reduce { copy(value = newValue) }\n}\n</code></pre> <p>Important characteristics:</p> <ul> <li>This property always returns the latest state, even after multiple <code>reduce</code> calls within the same intent handler</li> <li>The state is read-only; modifications must be done through <code>reduce</code></li> <li>Accessing state is synchronous and safe</li> </ul> <p>Example - Using state for conditional logic: <pre><code>onIntent&lt;MyIntent.Decrement&gt; { intent -&gt;\n    if (state.counter &gt; 0) {\n        reduce { copy(counter = counter - 1) }\n    } else {\n        sideEffect(MySideEffect.CounterMinimumReached)\n    }\n}\n</code></pre></p>"},{"location":"actor/actorscope/#scope","title":"scope","text":"<p>Type: <code>CoroutineScope</code></p> <p>The coroutine scope tied to the store's lifecycle:</p> <pre><code>onIntent&lt;MyIntent.LoadData&gt; { intent -&gt;\n    reduce { copy(loading = true) }\n\n    scope.launch {\n        try {\n            val data = repository.fetchData()\n            reduce { copy(loading = false, data = data) }\n        } catch (e: Exception) {\n            reduce { copy(loading = false, error = e.message) }\n        }\n    }\n}\n</code></pre> <p>Important characteristics:</p> <ul> <li>All coroutines launched in this scope are automatically cancelled when the store is destroyed</li> <li>The scope uses the <code>CoroutineContext</code> provided during store creation</li> <li>By default, uses <code>Dispatchers.Main.immediate</code></li> </ul> <p>Example - Multiple async operations: <pre><code>onIntent&lt;MyIntent.LoadProfile&gt; { intent -&gt;\n    reduce { copy(loading = true) }\n\n    scope.launch {\n        try {\n            // Launch parallel requests\n            val userDeferred = async { userRepository.getUser(intent.userId) }\n            val postsDeferred = async { postsRepository.getPosts(intent.userId) }\n\n            val user = userDeferred.await()\n            val posts = postsDeferred.await()\n\n            reduce {\n                copy(\n                    loading = false,\n                    user = user,\n                    posts = posts\n                )\n            }\n            sideEffect(MySideEffect.ProfileLoadSucceeded)\n        } catch (e: Exception) {\n            reduce { copy(loading = false, error = e.message) }\n            sideEffect(MySideEffect.ProfileLoadFailed(e.message ?: \"Unknown error\"))\n        }\n    }\n}\n</code></pre></p>"},{"location":"actor/actorscope/#functions","title":"Functions","text":""},{"location":"actor/actorscope/#reduce","title":"reduce","text":"<pre><code>fun reduce(block: State.() -&gt; State)\n</code></pre> <p>Updates the store's state. The lambda receives the current state and must return a new state:</p> <pre><code>// Simple state update\nreduce { copy(counter = counter + 1) }\n\n// Multiple property updates\nreduce { \n    copy(\n        counter = counter + 1,\n        lastUpdate = System.currentTimeMillis(),\n        isModified = true\n    )\n}\n\n// Conditional updates\nreduce {\n    if (counter &gt; 0) {\n        copy(counter = counter - 1)\n    } else {\n        this  // Return unchanged state\n    }\n}\n</code></pre> <p>Important rules:</p> <ul> <li>State must be immutable (use <code>data class</code> with <code>val</code> properties)</li> <li>Each <code>reduce</code> call creates a new state instance</li> <li>Middleware is notified of every state change</li> <li>The lambda should be a pure function without side effects</li> </ul> <p>Example - Complex state transformation: <pre><code>onIntent&lt;MyIntent.UpdateUser&gt; { intent -&gt;\n    reduce {\n        copy(\n            user = user.copy(\n                name = intent.newName,\n                email = intent.newEmail,\n                updatedAt = Clock.System.now()\n            ),\n            isDirty = true\n        )\n    }\n}\n</code></pre></p> <p>Anti-pattern - Side effects in reduce: <pre><code>// \u274c BAD - Don't do this\nreduce { \n    logEvent(\"state_changed\")  // Side effect!\n    copy(value = value + 1)\n}\n\n// \u2705 GOOD - Keep reduce pure\nreduce { copy(value = value + 1) }\nlogEvent(\"state_changed\")\n</code></pre></p>"},{"location":"actor/actorscope/#sideeffect","title":"sideEffect","text":"<pre><code>fun sideEffect(sideEffect: SideEffect)\n</code></pre> <p>Emits a side effect from the actor. Side effects represent one-time events that cannot be represented in state:</p> <pre><code>onIntent&lt;MyIntent.SaveData&gt; { intent -&gt;\n    reduce { copy(saving = true) }\n\n    scope.launch {\n        val result = repository.save(intent.data)\n\n        if (result.isSuccess) {\n            reduce { copy(saving = false) }\n            sideEffect(DataSideEffect.DataSaveSucceeded)\n        } else {\n            reduce { copy(saving = false, error = result.error) }\n            sideEffect(DataSideEffect.DataSaveFailed(result.error))\n        }\n    }\n}\n</code></pre> <p>Example side effects: <pre><code>sealed interface DataSideEffect {\n    data object DataSaveSucceeded : DataSideEffect\n    data class DataSaveFailed(val reason: String) : DataSideEffect\n    data class ValidationFailed(val errors: List&lt;String&gt;) : DataSideEffect\n    data object SessionExpired : DataSideEffect\n}\n</code></pre></p>"},{"location":"actor/actorscope/#intent","title":"intent","text":"<pre><code>fun intent(intent: Intent)\n</code></pre> <p>Dispatches a new intent to be processed by the actor. Useful for creating multi-step workflows:</p> <pre><code>onIntent&lt;MyIntent.StartProcess&gt; { intent -&gt;\n    reduce { copy(step = 1, status = \"Processing step 1\") }\n    // Process step 1...\n\n    // Move to next step\n    intent(MyIntent.ProcessStep2)\n}\n\nonIntent&lt;MyIntent.ProcessStep2&gt; { intent -&gt;\n    reduce { copy(step = 2, status = \"Processing step 2\") }\n    // Process step 2...\n\n    intent(MyIntent.ProcessStep3)\n}\n\nonIntent&lt;MyIntent.ProcessStep3&gt; { intent -&gt;\n    reduce { copy(step = 3, status = \"Process complete\") }\n    sideEffect(MySideEffect.ProcessCompleted)\n}\n</code></pre> <p>Use cases:</p> <ul> <li>Splitting complex logic into multiple steps</li> <li>Creating intent chains for sequential operations</li> <li>Conditional workflows based on state or results</li> </ul> <p>Example - Conditional intent dispatching: <pre><code>onIntent&lt;MyIntent.CheckAndLoad&gt; { intent -&gt;\n    if (state.isAuthenticated) {\n        intent(MyIntent.LoadUserData)\n    } else {\n        sideEffect(MySideEffect.AuthenticationRequired)\n    }\n}\n</code></pre></p> <p>Warning: Be careful not to create infinite loops: <pre><code>// \u274c BAD - Infinite loop!\nonIntent&lt;MyIntent.BadIntent&gt; { intent -&gt;\n    intent(MyIntent.BadIntent)  // Calls itself!\n}\n\n// \u2705 GOOD - Use conditions to break loops\nonIntent&lt;MyIntent.Retry&gt; { intent -&gt;\n    if (state.retryCount &lt; 3) {\n        reduce { copy(retryCount = retryCount + 1) }\n        scope.launch {\n            // Retry logic\n        }\n    } else {\n        sideEffect(MySideEffect.MaxRetriesReached)\n    }\n}\n</code></pre></p>"},{"location":"guides/bestpractices/","title":"Best Practices","text":"<p>This guide covers best practices for working with SimpleMVI to build maintainable, testable, and platform-independent applications.</p>"},{"location":"guides/bestpractices/#domain-focused-design","title":"Domain-Focused Design","text":""},{"location":"guides/bestpractices/#core-principle","title":"Core Principle","text":"<p>SimpleMVI is designed for domain logic organization. The Store should focus on business logic and domain events, not UI implementation details.</p>"},{"location":"guides/bestpractices/#side-effects-domain-events-not-ui-actions","title":"Side Effects: Domain Events, Not UI Actions","text":"<p>Side effects in SimpleMVI represent domain events - things that happened in your business logic. They should NOT represent UI actions or instructions.</p>"},{"location":"guides/bestpractices/#good-domain-events","title":"\u2705 Good - Domain Events","text":"<p>Domain events describe what happened in the business logic:</p> <pre><code>sealed interface UserSideEffect {\n    // Business events\n    data object LoginSucceeded : UserSideEffect\n    data class LoginFailed(val reason: String) : UserSideEffect\n    data object SessionExpired : UserSideEffect\n    data class PasswordChanged(val userId: String) : UserSideEffect\n}\n\nsealed interface OrderSideEffect {\n    // Business outcomes\n    data class OrderPlaced(val orderId: String) : OrderSideEffect\n    data class PaymentProcessed(val transactionId: String) : OrderSideEffect\n    data class OrderFailed(val reason: String) : OrderSideEffect\n    data object InventoryInsufficient : OrderSideEffect\n}\n\nsealed interface DataSideEffect {\n    // Operation results\n    data object DataSaveSucceeded : DataSideEffect\n    data class DataSaveFailed(val reason: String) : DataSideEffect\n    data class ValidationFailed(val errors: List&lt;String&gt;) : DataSideEffect\n    data object SyncCompleted : DataSideEffect\n}\n</code></pre>"},{"location":"guides/bestpractices/#bad-ui-actions","title":"\u274c Bad - UI Actions","text":"<p>UI-specific actions tell the UI what to do. This violates separation of concerns:</p> <pre><code>// DON'T DO THIS!\nsealed interface UserSideEffect {\n    data object NavigateToHome : UserSideEffect           // UI navigation\n    data object NavigateBack : UserSideEffect             // UI navigation\n    data class ShowToast(val message: String) : UserSideEffect  // UI presentation\n    data class ShowError(val message: String) : UserSideEffect  // UI presentation\n    data object ShowLoadingDialog : UserSideEffect        // UI state\n    data object HideKeyboard : UserSideEffect             // UI action\n}\n</code></pre>"},{"location":"guides/bestpractices/#why-domain-events-matter","title":"Why Domain Events Matter","text":""},{"location":"guides/bestpractices/#1-platform-independence","title":"1. Platform Independence","text":"<p>Domain events work across all platforms. The same Store can be used on Android, iOS, Desktop, and Web:</p> <pre><code>// This Store works everywhere\nclass UserStore : Store&lt;UserIntent, UserState, UserSideEffect&gt; by createStore(\n    name = storeName&lt;UserStore&gt;(),\n    initialState = UserState.Initial,\n    actor = userActor\n) {\n    sealed interface SideEffect {\n        data object LoginSucceeded : SideEffect  // Works on all platforms\n        data class LoginFailed(val reason: String) : SideEffect\n    }\n}\n</code></pre>"},{"location":"guides/bestpractices/#2-ui-flexibility","title":"2. UI Flexibility","text":"<p>Different platforms can handle the same event differently:</p> <pre><code>// Android - Navigate with Material Design\nLaunchedEffect(Unit) {\n    store.sideEffects.collect { sideEffect -&gt;\n        when (sideEffect) {\n            is UserSideEffect.LoginSucceeded -&gt; {\n                navController.navigate(\"home\")\n                Toast.makeText(context, \"Welcome!\", Toast.LENGTH_SHORT).show()\n            }\n        }\n    }\n}\n\n// iOS - Different UI approach for same event\n.onReceive(store.sideEffects) { sideEffect in\n    switch sideEffect {\n    case .loginSucceeded:\n        presentationMode.wrappedValue.dismiss()\n        showWelcomeAlert = true\n    }\n}\n\n// Desktop - Another approach\nscope.launch {\n    store.sideEffects.collect { sideEffect -&gt;\n        when (sideEffect) {\n            is UserSideEffect.LoginSucceeded -&gt; {\n                router.navigateTo(Route.Dashboard)\n                notificationService.show(\"Login successful\")\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"guides/bestpractices/#3-testability","title":"3. Testability","text":"<p>Domain events are easy to test without UI dependencies:</p> <pre><code>@Test\nfun `login with valid credentials emits LoginSucceeded`() = runTest {\n    val store = createUserStore()\n    val sideEffects = mutableListOf&lt;UserSideEffect&gt;()\n\n    store.sideEffects.onEach { sideEffects.add(it) }.launchIn(this)\n\n    store.accept(UserIntent.Login(\"user@example.com\", \"password\"))\n\n    advanceUntilIdle()\n\n    assertTrue(sideEffects.contains(UserSideEffect.LoginSucceeded))\n}\n</code></pre>"},{"location":"guides/bestpractices/#4-separation-of-concerns","title":"4. Separation of Concerns","text":"<p>Clear boundaries between layers:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502              UI Layer                   \u2502\n\u2502  (Platform-specific presentation)       \u2502\n\u2502  - Compose, SwiftUI, React              \u2502\n\u2502  - Navigation, Toasts, Dialogs          \u2502\n\u2502  - Interprets domain events             \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                    \u2193\n        Observes SideEffects\n                    \u2193\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502           Domain Layer                  \u2502\n\u2502  (Platform-independent logic)           \u2502\n\u2502  - Store, Actor, State                  \u2502\n\u2502  - Business rules                       \u2502\n\u2502  - Emits domain events                  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"guides/bestpractices/#store-organization","title":"Store Organization","text":""},{"location":"guides/bestpractices/#keep-stores-focused","title":"Keep Stores Focused","text":"<p>Each Store should have a single, well-defined responsibility:</p> <pre><code>// \u2705 GOOD - Focused stores\nclass AuthStore : Store&lt;AuthIntent, AuthState, AuthSideEffect&gt;\nclass ProfileStore : Store&lt;ProfileIntent, ProfileState, ProfileSideEffect&gt;\nclass SettingsStore : Store&lt;SettingsIntent, SettingsState, SettingsSideEffect&gt;\n\n// \u274c BAD - God object\nclass AppStore : Store&lt;AppIntent, AppState, AppSideEffect&gt;  // Everything in one store!\n</code></pre>"},{"location":"guides/bestpractices/#state-structure","title":"State Structure","text":"<p>Keep state flat and immutable:</p> <pre><code>// \u2705 GOOD - Flat, immutable state\ndata class UserState(\n    val isLoading: Boolean = false,\n    val user: User? = null,\n    val error: String? = null,\n    val isAuthenticated: Boolean = false\n)\n\n// \u274c BAD - Nested mutable state\ndata class UserState(\n    var status: Status,  // Mutable!\n    val data: MutableMap&lt;String, Any&gt;  // Mutable!\n)\n</code></pre>"},{"location":"guides/bestpractices/#intent-design","title":"Intent Design","text":"<p>Intents should be clear and represent user actions or system events:</p> <pre><code>// \u2705 GOOD - Clear intent names\nsealed interface UserIntent {\n    data class Login(val email: String, val password: String) : UserIntent\n    data object Logout : UserIntent\n    data class UpdateProfile(val name: String, val avatar: Uri) : UserIntent\n    data object RefreshData : UserIntent\n}\n\n// \u274c BAD - Unclear intent names\nsealed interface UserIntent {\n    data class DoStuff(val data: Any) : UserIntent\n    data object Action1 : UserIntent\n    data object Action2 : UserIntent\n}\n</code></pre>"},{"location":"guides/bestpractices/#actor-best-practices","title":"Actor Best Practices","text":""},{"location":"guides/bestpractices/#choose-the-right-approach","title":"Choose the Right Approach","text":"<p>Use the approach that fits your needs:</p> <ul> <li>DefaultActor: Complex business logic, large projects</li> <li>actorDsl: Simple logic, quick development</li> <li>delegatedActor: Modular composition, code generation</li> </ul>"},{"location":"guides/bestpractices/#keep-business-logic-in-actors","title":"Keep Business Logic in Actors","text":"<pre><code>// \u2705 GOOD - Business logic in Actor\nclass OrderActor : DefaultActor&lt;OrderIntent, OrderState, OrderSideEffect&gt;() {\n    override fun handleIntent(intent: OrderIntent) {\n        when (intent) {\n            is OrderIntent.PlaceOrder -&gt; {\n                if (!validateOrder(intent.order)) {\n                    sideEffect(OrderSideEffect.ValidationFailed(getErrors()))\n                    return\n                }\n\n                processOrder(intent.order)\n            }\n        }\n    }\n\n    private fun validateOrder(order: Order): Boolean {\n        // Business validation logic\n    }\n}\n\n// \u274c BAD - UI logic in Actor\nclass OrderActor : DefaultActor&lt;OrderIntent, OrderState, OrderSideEffect&gt;() {\n    override fun handleIntent(intent: OrderIntent) {\n        when (intent) {\n            is OrderIntent.PlaceOrder -&gt; {\n                // Don't do UI-specific logic here!\n                sideEffect(OrderSideEffect.ShowLoadingDialog)\n                sideEffect(OrderSideEffect.NavigateToCheckout)\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"guides/bestpractices/#pure-state-reducers","title":"Pure State Reducers","text":"<p>Keep <code>reduce</code> blocks pure:</p> <pre><code>// \u2705 GOOD - Pure reducer\nreduce { \n    copy(\n        items = items + newItem,\n        totalPrice = calculateTotal(items + newItem)\n    )\n}\n\n// \u274c BAD - Side effects in reducer\nreduce {\n    logger.log(\"Adding item\")  // Side effect!\n    analytics.track(\"item_added\")  // Side effect!\n    copy(items = items + newItem)\n}\n</code></pre>"},{"location":"guides/bestpractices/#error-handling","title":"Error Handling","text":""},{"location":"guides/bestpractices/#always-handle-errors","title":"Always Handle Errors","text":"<pre><code>// \u2705 GOOD - Proper error handling\nonIntent&lt;DataIntent.LoadData&gt; { intent -&gt;\n    reduce { copy(loading = true, error = null) }\n\n    scope.launch {\n        try {\n            val data = repository.loadData()\n            reduce { copy(loading = false, data = data) }\n            sideEffect(DataSideEffect.DataLoadSucceeded)\n        } catch (e: Exception) {\n            reduce { copy(loading = false, error = e.message) }\n            sideEffect(DataSideEffect.DataLoadFailed(e.message ?: \"Unknown error\"))\n        }\n    }\n}\n\n// \u274c BAD - No error handling\nonIntent&lt;DataIntent.LoadData&gt; { intent -&gt;\n    scope.launch {\n        val data = repository.loadData()  // Can crash!\n        reduce { copy(data = data) }\n    }\n}\n</code></pre>"},{"location":"guides/bestpractices/#specific-error-types","title":"Specific Error Types","text":"<p>Use specific error types for better handling:</p> <pre><code>// \u2705 GOOD - Specific errors\nsealed interface DataSideEffect {\n    data class NetworkError(val code: Int) : DataSideEffect\n    data class ValidationError(val fields: List&lt;String&gt;) : DataSideEffect\n    data object UnauthorizedError : DataSideEffect\n    data class UnknownError(val message: String) : DataSideEffect\n}\n\n// \u274c BAD - Generic errors\nsealed interface DataSideEffect {\n    data class Error(val message: String) : DataSideEffect\n}\n</code></pre>"},{"location":"guides/bestpractices/#testing","title":"Testing","text":""},{"location":"guides/bestpractices/#test-store-in-isolation","title":"Test Store in Isolation","text":"<pre><code>@Test\nfun `place order with valid data should succeed`() = runTest {\n    val store = createOrderStore()\n    val sideEffects = mutableListOf&lt;OrderSideEffect&gt;()\n\n    store.sideEffects.onEach { sideEffects.add(it) }.launchIn(this)\n\n    val order = createValidOrder()\n    store.accept(OrderIntent.PlaceOrder(order))\n\n    advanceUntilIdle()\n\n    assertEquals(OrderState.Success, store.state)\n    assertTrue(sideEffects.any { it is OrderSideEffect.OrderPlaced })\n}\n</code></pre>"},{"location":"guides/bestpractices/#lifecycle-management","title":"Lifecycle Management","text":""},{"location":"guides/bestpractices/#always-destroy-stores","title":"Always Destroy Stores","text":"<pre><code>// \u2705 GOOD - Proper cleanup\nclass MyViewModel : ViewModel() {\n    private val store = MyStore()\n\n    init {\n        store.init()\n    }\n\n    override fun onCleared() {\n        store.destroy()\n        super.onCleared()\n    }\n}\n\n// \u274c BAD - No cleanup\nclass MyViewModel : ViewModel() {\n    private val store = MyStore().apply { init() }\n    // No destroy() call - resource leak!\n}\n</code></pre>"},{"location":"guides/bestpractices/#summary","title":"Summary","text":"<p>The key principles for working with SimpleMVI:</p> <ol> <li>Domain events, not UI actions - Side effects represent business events</li> <li>Platform independence - Same Store works everywhere</li> <li>Separation of concerns - UI interprets, Store decides</li> <li>Focused stores - One responsibility per store</li> <li>Immutable state - No mutable data structures</li> <li>Pure reducers - No side effects in reduce blocks</li> <li>Proper error handling - Always handle and report errors</li> <li>Test everything - Stores and actors are highly testable</li> <li>Clean lifecycle - Always destroy stores</li> <li>Use the right tool - Choose the Actor approach that fits your needs</li> </ol>"},{"location":"logging/logging/","title":"WIP","text":""},{"location":"middleware/middleware/","title":"Middleware","text":"<p>The <code>Middleware</code> is designed to provide a way to \"spy\" on the <code>Store</code> without modifying its behavior. It's useful for implementing cross-cutting concerns such as logging, analytics, or debugging.</p>"},{"location":"middleware/middleware/#overview","title":"Overview","text":"<p><code>Middleware</code> allows you to:</p> <ul> <li>Observe <code>Store</code> initialization</li> <li>Observe <code>Intent</code> received by the <code>Store</code></li> <li>Monitor <code>State</code> changes</li> <li>Track <code>SideEffect</code> production</li> <li>Observe <code>Store</code> destruction</li> </ul> <p>It's important to note that <code>Middleware</code> cannot modify the input events it observes.</p>"},{"location":"middleware/middleware/#interface-definition","title":"Interface Definition","text":"<pre><code>public interface Middleware&lt;Intent : Any, State : Any, SideEffect : Any&gt; {\n    /**\n     * Called when the Store is initialized\n     */\n    public fun onInit(state: State)\n\n    /**\n     * Called when the Store receives a new Intent\n     */\n    public fun onIntent(intent: Intent, state: State)\n\n    /**\n     * Called when a new State is produced inside the Actor\n     */\n    public fun onStateChanged(oldState: State, newState: State)\n\n    /**\n     * Called when the Actor produces a new SideEffect\n     */\n    public fun onSideEffect(sideEffect: SideEffect, state: State)\n\n    /**\n     * Called when the Store is destroyed\n     */\n    public fun onDestroy(state: State)\n}\n</code></pre>"},{"location":"middleware/middleware/#key-methods","title":"Key Methods","text":""},{"location":"middleware/middleware/#oninit","title":"onInit","text":"<pre><code>public fun onInit(state: State)\n</code></pre> <p>This method is called when the <code>Store</code> is initialized, providing access to the initial state. This is useful for:</p> <ul> <li>Setting up analytics tracking</li> <li>Initializing performance monitoring</li> <li>Logging store creation</li> </ul> <p>Timing: Called during <code>Store.init()</code>, before any intents are processed.</p>"},{"location":"middleware/middleware/#onintent","title":"onIntent","text":"<pre><code>public fun onIntent(intent: Intent, state: State)\n</code></pre> <p>This method is invoked when the <code>Store</code> receives a new <code>Intent</code>. It provides access to:</p> <ul> <li>The received <code>Intent</code></li> <li>The current <code>State</code> at the time the <code>Intent</code> was received</li> </ul> <p>Timing: Called before the <code>Actor</code> processes the intent, allowing the middleware to observe the intent before any state changes occur.</p>"},{"location":"middleware/middleware/#onstatechanged","title":"onStateChanged","text":"<pre><code>public fun onStateChanged(oldState: State, newState: State)\n</code></pre> <p>This method is called when a new <code>State</code> is produced inside the <code>Actor</code>. It provides access to:</p> <ul> <li>The previous <code>State</code></li> <li>The new <code>State</code></li> </ul> <p>This allows for easy comparison and tracking of state changes.</p> <p>Timing: Called immediately after a state reduction, before the new state is emitted to collectors.</p>"},{"location":"middleware/middleware/#onsideeffect","title":"onSideEffect","text":"<pre><code>public fun onSideEffect(sideEffect: SideEffect, state: State)\n</code></pre> <p>This method is invoked when the <code>Actor</code> produces a new <code>SideEffect</code>. It provides access to:</p> <ul> <li>The produced <code>SideEffect</code></li> <li>The current <code>State</code> at the time the <code>SideEffect</code> was produced</li> </ul> <p>Timing: Called when a side effect is emitted but before it's delivered to collectors.</p>"},{"location":"middleware/middleware/#ondestroy","title":"onDestroy","text":"<pre><code>public fun onDestroy(state: State)\n</code></pre> <p>This method is called when the <code>Store</code> is being destroyed, right before resources are released. It provides access to:</p> <ul> <li>The final <code>State</code> of the <code>Store</code></li> </ul> <p>Important: This is the last method called on the middleware. The <code>CoroutineScope</code> is still active when this method is called.</p> <p>Use cases: - Flushing analytics events - Cleaning up middleware resources - Logging store lifecycle completion</p>"},{"location":"middleware/middleware/#use-cases","title":"Use Cases","text":"<p><code>Middleware</code> can be used for various purposes, including but not limited to:</p> <ol> <li>Logging: Track all events passing through the <code>Store</code> for debugging or auditing purposes.</li> <li>Analytics: Capture user actions and state changes for analysis.</li> <li>Debugging: Monitor the flow of <code>Intent</code>, <code>State</code>, and <code>SideEffect</code> for troubleshooting.</li> <li>Performance Monitoring: Track the frequency and timing of state changes and side effects.</li> <li>Testing: Verify the sequence and correctness of store events during tests.</li> </ol>"},{"location":"middleware/middleware/#example-implementation","title":"Example Implementation","text":""},{"location":"middleware/middleware/#simple-logging-middleware","title":"Simple Logging Middleware","text":"<pre><code>class SimpleLoggingMiddleware&lt;Intent : Any, State : Any, SideEffect : Any&gt;(\n    private val tag: String\n) : Middleware&lt;Intent, State, SideEffect&gt; {\n\n    override fun onInit(state: State) {\n        println(\"[$tag] Initialized with state: $state\")\n    }\n\n    override fun onIntent(intent: Intent, state: State) {\n        println(\"[$tag] Intent: $intent\")\n    }\n\n    override fun onStateChanged(oldState: State, newState: State) {\n        println(\"[$tag] State changed from $oldState to $newState\")\n    }\n\n    override fun onSideEffect(sideEffect: SideEffect, state: State) {\n        println(\"[$tag] Side effect: $sideEffect\")\n    }\n\n    override fun onDestroy(state: State) {\n        println(\"[$tag] Destroyed with final state: $state\")\n    }\n}\n</code></pre>"},{"location":"middleware/middleware/#analytics-middleware","title":"Analytics Middleware","text":"<pre><code>class AnalyticsMiddleware&lt;Intent : Any, State : Any, SideEffect : Any&gt;(\n    private val analytics: AnalyticsService\n) : Middleware&lt;Intent, State, SideEffect&gt; {\n\n    override fun onInit(state: State) {\n        analytics.logEvent(\"store_initialized\")\n    }\n\n    override fun onIntent(intent: Intent, state: State) {\n        analytics.logEvent(\n            \"intent_received\",\n            mapOf(\"intent\" to intent::class.simpleName)\n        )\n    }\n\n    override fun onStateChanged(oldState: State, newState: State) {\n        analytics.logEvent(\"state_changed\")\n    }\n\n    override fun onSideEffect(sideEffect: SideEffect, state: State) {\n        analytics.logEvent(\n            \"side_effect\",\n            mapOf(\"effect\" to sideEffect::class.simpleName)\n        )\n    }\n\n    override fun onDestroy(state: State) {\n        analytics.logEvent(\"store_destroyed\")\n    }\n}\n</code></pre>"},{"location":"middleware/middleware/#using-middleware","title":"Using Middleware","text":"<p>Middleware can be registered when creating a store:</p> <pre><code>val store = createStore(\n    name = storeName&lt;MyStore&gt;(),\n    initialState = MyState(),\n    actor = myActor,\n    middlewares = listOf(\n        loggingMiddleware,\n        analyticsMiddleware,\n        customDebugMiddleware\n    )\n)\n</code></pre> <p>Multiple middleware instances can be used simultaneously, and they will be notified in the order they were registered.</p>"},{"location":"middleware/middleware/#important-notes","title":"Important Notes","text":"<ul> <li><code>Middleware</code> is a passive observer and cannot modify the events it receives.</li> <li>Multiple <code>Middleware</code> instances can be used simultaneously in a single <code>Store</code>.</li> <li><code>Middleware</code> methods should be implemented efficiently to avoid impacting the performance of the main application logic.</li> <li>While <code>Middleware</code> has access to the <code>State</code>, it should not attempt to modify it directly.</li> <li>All <code>Middleware</code> methods are called synchronously on the same thread where the store operation occurred.</li> </ul> <p>For more information on how <code>Middleware</code> interacts with other components, refer to the <code>Store</code> and <code>Actor</code> documentation.</p>"},{"location":"overview/configuration/","title":"SimpleMVI Configuration","text":"<p>SimpleMVI provides a flexible configuration system that allows you to customize library behavior including error handling and logging.</p>"},{"location":"overview/configuration/#configuration-options","title":"Configuration Options","text":""},{"location":"overview/configuration/#error-handling","title":"Error Handling","text":"<p>You can configure how the library behaves when it encounters errors such as:</p> <ul> <li>Using an uninitialized Store</li> <li>Using a destroyed Store</li> </ul> <pre><code>// Configuration for development environment\nconfigureSimpleMVI {\n    // Strict mode: throw exceptions when errors occur\n    strictMode = true\n}\n\n// Configuration for production environment (default)\nconfigureSimpleMVI {\n    // Lenient mode: only log errors without throwing exceptions (default)\n    strictMode = false\n}\n</code></pre> <p>Error handling modes:</p> <ul> <li><code>strictMode = true</code> - The library operates in strict mode and throws exceptions when errors are detected. Recommended for development to catch issues early.</li> <li><code>strictMode = false</code> (default) - The library operates in lenient mode and only logs errors without throwing exceptions. Recommended for production to prevent crashes from store misuse.</li> </ul>"},{"location":"overview/configuration/#logging","title":"Logging","text":"<p>You can configure the logger used by the library:</p> <pre><code>// Setting a custom logger\nconfigureSimpleMVI {\n    logger = MyCustomLogger()\n}\n\n// Disabling logging completely\nconfigureSimpleMVI {\n    logger = null\n}\n</code></pre> <p>By default, <code>DefaultLogger</code> is used. If you set <code>logger</code> to <code>null</code>, logging will be disabled.</p>"},{"location":"overview/configuration/#legacy-logging-configuration","title":"Legacy Logging Configuration","text":"<p>For backward compatibility, the library still supports the legacy <code>setDefaultLogger()</code> method, but it's deprecated and will be removed in future versions:</p> <pre><code>// Legacy way to set logger (deprecated)\nsetDefaultLogger(MyCustomLogger())\n\n// Recommended way\nconfigureSimpleMVI {\n    logger = MyCustomLogger()\n}\n</code></pre> <p>Note: When using <code>setDefaultLogger()</code>, other configuration values like <code>strictMode</code> are preserved.</p>"},{"location":"overview/configuration/#complete-configuration-example","title":"Complete Configuration Example","text":"<pre><code>// Complete configuration\nconfigureSimpleMVI {\n    // Use lenient mode for production (default)\n    strictMode = false\n\n    // Set custom logger\n    logger = object : Logger {\n        override fun log(message: String) {\n            // Forward to your logging system\n            MyLoggingSystem.log(message)\n        }\n    }\n}\n</code></pre>"},{"location":"overview/configuration/#usage-in-different-environments","title":"Usage in Different Environments","text":"<p>A common approach is to use different configurations for different environments:</p> <pre><code>// In Application.onCreate() or another initialization point\nif (BuildConfig.DEBUG) {\n    // Configuration for development\n    configureSimpleMVI {\n        strictMode = true\n        logger = DebugLogger()\n    }\n} else {\n    // Configuration for production\n    configureSimpleMVI {\n        strictMode = false\n        logger = ReleaseLogger()\n    }\n}\n</code></pre>"},{"location":"overview/configuration/#notes","title":"Notes","text":"<ol> <li>Configuration is set globally for all Store instances.</li> <li>In lenient mode (strictMode = false), errors will be logged if a logger is configured.</li> <li>The name <code>strictMode</code> follows common practice in Android and other platforms, where this term describes a mode with stricter checks.</li> <li>If you need to create your own logger, implement the <code>Logger</code> interface with a single <code>log(message: String)</code> method.</li> <li>All configuration settings are applied immediately and affect all future operations.</li> </ol>"},{"location":"overview/quickstart/","title":"Quick start","text":""},{"location":"overview/quickstart/#modifying-build-script","title":"Modifying build script","text":"<p>Add a new dependency to the gradle build script</p> KotlinGroovy <pre><code>implementation(\"io.github.arttttt.simplemvi:simplemvi:&lt;version&gt;\")\n</code></pre> <pre><code>implementation \"io.github.arttttt.simplemvi:simplemvi:&lt;version&gt;\"\n</code></pre>"},{"location":"overview/quickstart/#creating-store","title":"Creating Store","text":"<p>This easiest way to create a <code>Store</code> is declaring an object which impletents the <code>Store</code> interface</p> <pre><code>class MyCoolStore : Store&lt;MyCoolStore.Intent, MyCoolStore.State, MyCoolStore.SideEffect&gt; {\n\n    sealed interface Intent\n\n    data class State(val value: Int = 0)\n\n    sealed interface SideEffect\n}\n</code></pre> <p>Now it's necessary to implement the <code>Store</code> interface itself. It can be done by using the <code>createStore</code> function</p> <pre><code>class MyCoolStore : Store&lt;/* omitted code */&gt; by createStore(\n    name = storeName&lt;MyCoolStore&gt;(),\n    initialState = //Store initial state,\n    actor = //Store actor,\n) {\n\n    // Omitted code\n}\n</code></pre> <p>There are only three mandatory parameters that need to be provided: <code>name</code>, <code>initialState</code> and <code>actor</code></p> <p><code>name</code> - name of the <code>Store</code>. It's used for logging and debugging. It's possible to pass <code>null</code></p> <p><code>initialState</code> - initial state of the <code>Store</code>. A brand new instance of the <code>Store</code> is created with this provided state</p> <p><code>actor</code> - a place where all business logic is placed</p>"},{"location":"overview/quickstart/#creating-actor","title":"Creating Actor","text":"<p><code>Actor</code> can be created by using dsl</p> <pre><code>class MyCoolStore : Store&lt;/* omitted code */&gt; by createStore(\n    name = //Store name\n    initialState = //Store initial state,\n    actor = actorDsl {\n        onInit { /* code */ }\n\n        onIntent&lt;Intent.DoCoolStuff&gt; { intent -&gt; /* code */ }\n\n        onDestroy { /* code */ }\n    },\n) {\n    sealed interface Intent {\n        data object DoCoolStuff : Intent\n    }\n\n    // Omitted code\n}\n</code></pre> <p><code>onInit</code> - called when the <code>Store</code> initialized</p> <p><code>onIntent&lt;T&gt;</code> - called when a declared intent received</p> <p><code>onDestroy</code> - called when store is about to be destroyed, but <code>CoroutineScope</code> is still active</p> <p>That's basically it!</p>"},{"location":"store/createstore/","title":"Creating Stores","text":""},{"location":"store/createstore/#createstore-function","title":"createStore Function","text":"<p>The <code>createStore</code> function is the primary way to create a <code>Store</code> instance:</p> <pre><code>public fun &lt;Intent : Any, State : Any, SideEffect : Any&gt; createStore(\n    name: StoreName?,\n    initialize: Boolean = true,\n    coroutineContext: CoroutineContext = Dispatchers.Main.immediate,\n    initialState: State,\n    initialIntents: List&lt;Intent&gt; = emptyList(),\n    middlewares: List&lt;Middleware&lt;Intent, State, SideEffect&gt;&gt; = emptyList(),\n    actor: Actor&lt;Intent, State, SideEffect&gt;,\n): Store&lt;Intent, State, SideEffect&gt;\n</code></pre>"},{"location":"store/createstore/#parameters","title":"Parameters","text":""},{"location":"store/createstore/#name-required","title":"name (required)","text":"<p>Type: <code>StoreName?</code></p> <p>The name of the store, used for logging and debugging. Use the <code>storeName&lt;T&gt;()</code> helper function:</p> <pre><code>name = storeName&lt;MyStore&gt;()\n</code></pre> <p>You can also pass <code>null</code> to disable automatic logging:</p> <pre><code>name = null  // No automatic logging middleware\n</code></pre> <p>Note: If you provide a non-null <code>name</code> and have configured a logger via <code>configureSimpleMVI</code>, a <code>LoggingMiddleware</code> will be automatically added to your store.</p>"},{"location":"store/createstore/#initialstate-required","title":"initialState (required)","text":"<p>Type: <code>State</code></p> <p>The initial state of the store. This is the state before any intents are processed:</p> <pre><code>initialState = MyState(\n    counter = 0,\n    isLoading = false\n)\n</code></pre> <p>Best practices:</p> <ul> <li>Use immutable data classes for state</li> <li>Provide sensible defaults for all properties</li> <li>Keep state structure flat when possible</li> </ul>"},{"location":"store/createstore/#actor-required","title":"actor (required)","text":"<p>Type: <code>Actor&lt;Intent, State, SideEffect&gt;</code></p> <p>The actor that contains all business logic. Can be created using three approaches:</p> <pre><code>// 1. Using actorDsl\nactor = actorDsl {\n    onIntent&lt;MyIntent.DoSomething&gt; { /* ... */ }\n}\n\n// 2. Using DefaultActor\nactor = MyCustomActor()\n\n// 3. Using delegatedActor with explicit handlers\nactor = delegatedActor(\n    intentHandlers = listOf(\n        myIntentHandler1(),\n        myIntentHandler2()\n    )\n)\n</code></pre> <p>For more details on Actor implementations, see the Actor documentation.</p>"},{"location":"store/createstore/#initialize-optional","title":"initialize (optional)","text":"<p>Type: <code>Boolean</code> Default: <code>true</code></p> <p>Whether to automatically call <code>Store.init()</code> after creation:</p> <pre><code>// Automatic initialization (default)\nval store = createStore(\n    name = storeName&lt;MyStore&gt;(),\n    initialize = true,  // Store is ready to use immediately\n    initialState = MyState(),\n    actor = myActor\n)\nstore.accept(MyIntent.DoSomething)  // Can use immediately\n\n// Manual initialization\nval store = createStore(\n    name = storeName&lt;MyStore&gt;(),\n    initialize = false,  // Must call init() manually\n    initialState = MyState(),\n    actor = myActor\n)\nstore.init()  // Must call this before using\nstore.accept(MyIntent.DoSomething)\n</code></pre> <p>When to use manual initialization:</p> <ul> <li>When you need to delay store initialization until a specific time</li> <li>In testing scenarios where you want precise control over initialization</li> <li>When integrating with lifecycle-aware components</li> </ul>"},{"location":"store/createstore/#coroutinecontext-optional","title":"coroutineContext (optional)","text":"<p>Type: <code>CoroutineContext</code> Default: <code>Dispatchers.Main.immediate</code></p> <p>The coroutine context used by the store for launching coroutines within the actor:</p> <pre><code>// Default: Main dispatcher (recommended for UI-related stores)\ncreateStore(\n    name = storeName&lt;MyStore&gt;(),\n    coroutineContext = Dispatchers.Main.immediate,\n    initialState = MyState(),\n    actor = myActor\n)\n\n// Custom context for specific use cases\ncreateStore(\n    name = storeName&lt;MyStore&gt;(),\n    coroutineContext = Dispatchers.Default + SupervisorJob(),\n    initialState = MyState(),\n    actor = myActor\n)\n</code></pre> <p>Note: The default <code>Dispatchers.Main.immediate</code> is recommended for stores that interact with UI, as it ensures state updates are immediately available to the UI layer. For background-only stores, you may choose a different dispatcher.</p>"},{"location":"store/createstore/#initialintents-optional","title":"initialIntents (optional)","text":"<p>Type: <code>List&lt;Intent&gt;</code> Default: <code>emptyList()</code></p> <p>A list of intents to process immediately after initialization:</p> <pre><code>createStore(\n    name = storeName&lt;MyStore&gt;(),\n    initialState = MyState(),\n    actor = myActor,\n    initialIntents = listOf(\n        MyIntent.LoadInitialData,\n        MyIntent.CheckAuthStatus\n    )\n)\n</code></pre> <p>This is equivalent to: <pre><code>val store = createStore(...)\nstore.accept(MyIntent.LoadInitialData)\nstore.accept(MyIntent.CheckAuthStatus)\n</code></pre></p> <p>Use cases:</p> <ul> <li>Loading initial data when the store starts</li> <li>Triggering startup tasks</li> <li>Setting up subscriptions or listeners</li> </ul>"},{"location":"store/createstore/#middlewares-optional","title":"middlewares (optional)","text":"<p>Type: <code>List&lt;Middleware&lt;Intent, State, SideEffect&gt;&gt;</code> Default: <code>emptyList()</code></p> <p>A list of middleware to observe store events:</p> <pre><code>createStore(\n    name = storeName&lt;MyStore&gt;(),\n    initialState = MyState(),\n    actor = myActor,\n    middlewares = listOf(\n        analyticsMiddleware,\n        customLoggingMiddleware,\n        performanceMiddleware\n    )\n)\n</code></pre> <p>Note: If you provide a <code>name</code> and have configured a logger via <code>configureSimpleMVI</code>, a <code>LoggingMiddleware</code> will be automatically prepended to your middleware list.</p> <p>Middleware execution order:</p> <ol> <li>Automatic <code>LoggingMiddleware</code> (if name is provided and logger is configured)</li> <li>Your custom middlewares in the order they appear in the list</li> </ol>"},{"location":"store/createstore/#complete-example-with-domain-focused-design","title":"Complete Example with Domain-Focused Design","text":"<pre><code>@DelegatedStore  // Optional: enables code generation\nclass CounterStore : Store&lt;CounterStore.Intent, CounterStore.State, CounterStore.SideEffect&gt; by createStore(\n    name = storeName&lt;CounterStore&gt;(),\n    initialize = true,\n    initialState = State(counter = 0),\n    initialIntents = listOf(Intent.Initialize),\n    middlewares = listOf(analyticsMiddleware),\n    actor = delegatedActor(\n        initHandler = InitHandler {\n            // Optional: initialization logic\n        },\n        intentHandlers = listOf(\n            incrementIntentHandler(),\n            decrementIntentHandler(),\n            resetIntentHandler()\n        ),\n        destroyHandler = DestroyHandler {\n            // Optional: cleanup logic\n        }\n    )\n) {\n    sealed interface Intent {\n        data object Initialize : Intent\n        data object Increment : Intent\n        data object Decrement : Intent\n        data object Reset : Intent\n    }\n\n    data class State(\n        val counter: Int,\n        val initialized: Boolean = false\n    )\n\n    // Domain events, not UI actions\n    sealed interface SideEffect {\n        data class CounterChanged(val value: Int) : SideEffect\n        data object CounterReset : SideEffect\n        data object MinimumReached : SideEffect\n        data object MaximumReached : SideEffect\n    }\n}\n\n// Intent handlers (can be in separate files)\nfun incrementIntentHandler() = counterStoreIntentHandler&lt;CounterStore.Intent.Increment&gt; { intent -&gt;\n    if (state.counter &gt;= 100) {\n        sideEffect(CounterStore.SideEffect.MaximumReached)\n        return@counterStoreIntentHandler\n    }\n\n    reduce { copy(counter = counter + 1) }\n    sideEffect(CounterStore.SideEffect.CounterChanged(state.counter))\n}\n\nfun decrementIntentHandler() = counterStoreIntentHandler&lt;CounterStore.Intent.Decrement&gt; { intent -&gt;\n    if (state.counter &lt;= 0) {\n        sideEffect(CounterStore.SideEffect.MinimumReached)\n        return@counterStoreIntentHandler\n    }\n\n    reduce { copy(counter = counter - 1) }\n    sideEffect(CounterStore.SideEffect.CounterChanged(state.counter))\n}\n\nfun resetIntentHandler() = counterStoreIntentHandler&lt;CounterStore.Intent.Reset&gt; { intent -&gt;\n    reduce { copy(counter = 0) }\n    sideEffect(CounterStore.SideEffect.CounterReset)\n}\n</code></pre>"},{"location":"store/createstore/#code-generation","title":"Code Generation","text":"<p>SimpleMVI provides KSP-based code generation to simplify working with <code>delegatedActor</code> and intent handlers.</p>"},{"location":"store/createstore/#setup","title":"Setup","text":"<p>Add the code generation dependencies to your build file:</p> <pre><code>// build.gradle.kts\nplugins {\n    id(\"com.google.devtools.ksp\") version \"&lt;version&gt;\"\n}\n\ndependencies {\n    implementation(\"io.github.arttttt.simplemvi:simplemvi:&lt;version&gt;\")\n    implementation(\"io.github.arttttt.simplemvi:simplemvi-annotations:&lt;version&gt;\")\n    ksp(\"io.github.arttttt.simplemvi:simplemvi-codegen:&lt;version&gt;\")\n}\n</code></pre>"},{"location":"store/createstore/#delegatedstore-annotation","title":"@DelegatedStore Annotation","text":"<p>Annotate your Store with <code>@DelegatedStore</code> to generate type-safe handler factories:</p> <pre><code>@DelegatedStore\nclass MyStore : Store&lt;/* ... */&gt; by createStore(/* ... */) {\n    // Your Store definition\n}\n</code></pre> <p>Generated code:</p> <p>For a store <code>MyStore</code>, the annotation generates: - Intent handler factory: <code>myStoreIntentHandler&lt;T&gt;()</code> for creating type-safe intent handlers - Init handler factory: <code>myStoreInitHandler()</code> for initialization logic - Destroy handler factory: <code>myStoreDestroyHandler()</code> for cleanup logic - Proper type inference for Intent, State, and SideEffect types</p> <p>Benefits:</p> <ul> <li>Less boilerplate code</li> <li>Type-safe intent handler creation</li> <li>Type-safe lifecycle handler creation</li> <li>Better IDE support and autocomplete</li> <li>Compile-time safety</li> </ul> <p>For more details, see the Actor documentation.</p>"},{"location":"store/createstore/#store-operators","title":"Store Operators","text":"<p>SimpleMVI provides convenient operators for working with stores:</p>"},{"location":"store/createstore/#accept-operator","title":"Accept Operator (+)","text":"<pre><code>// Instead of store.accept(intent)\nstore + MyStore.Intent.DoSomething\n\n// Example usage\ncounterStore + CounterStore.Intent.Increment\ncounterStore + CounterStore.Intent.Decrement\n</code></pre>"},{"location":"store/createstore/#compound-assignment-operator","title":"Compound Assignment Operator (+=)","text":"<pre><code>// Equivalent to store.accept(intent)\nstore += MyStore.Intent.DoSomething\n</code></pre> <p>These operators make code more concise and readable, especially when dispatching multiple intents.</p>"},{"location":"store/createstore/#store-delegation-pattern","title":"Store Delegation Pattern","text":"<p>The recommended pattern is to use store delegation with the <code>by</code> keyword:</p> <pre><code>class MyStore : Store&lt;Intent, State, SideEffect&gt; by createStore(\n    name = storeName&lt;MyStore&gt;(),\n    initialState = State(),\n    actor = myActor\n) {\n    // Your Intent, State, SideEffect definitions here\n}\n</code></pre> <p>Benefits:</p> <ul> <li>Clean separation of concerns</li> <li>All store functionality is automatically implemented</li> <li>Easy to add custom methods or properties if needed</li> <li>Standard pattern across the codebase</li> </ul>"},{"location":"store/createstore/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Always provide a name for logging during development: <pre><code>name = storeName&lt;MyStore&gt;()  // Good for debugging\n</code></pre></p> </li> <li> <p>Use descriptive initial states: <pre><code>initialState = State(\n    isLoading = false,\n    data = null,\n    error = null\n)\n</code></pre></p> </li> <li> <p>Keep the actor focused on business logic:</p> <ul> <li>Don't mix UI logic in actors</li> <li>Use side effects for domain events</li> <li>Keep state updates pure</li> </ul> </li> <li> <p>Use initialIntents sparingly:</p> <ul> <li>Only for critical startup tasks</li> <li>Consider if initialization logic belongs in <code>onInit</code> instead</li> </ul> </li> <li> <p>Always destroy stores when done: <pre><code>// In a lifecycle-aware component\noverride fun onDestroy() {\n    super.onDestroy()\n    store.destroy()\n}\n</code></pre></p> </li> </ol>"},{"location":"store/store/","title":"Store","text":"<p>The <code>Store</code> is designed to encapsulate different logic in applications. It allows to design apps using unidirectional data flow and a single source of truth.</p>"},{"location":"store/store/#key-characteristics","title":"Key Characteristics","text":"<ul> <li><code>Store</code> has its own <code>State</code></li> <li>It can accept <code>Intent</code></li> <li>It can emit <code>SideEffect</code></li> </ul>"},{"location":"store/store/#lifecycle","title":"Lifecycle","text":"<ul> <li>Must be initialized before use by calling <code>Store.init()</code></li> <li>Must be destroyed by calling <code>Store.destroy()</code> when no longer needed to free up resources</li> </ul>"},{"location":"store/store/#key-components","title":"Key Components","text":""},{"location":"store/store/#actor","title":"Actor","text":"<p>Every <code>Store</code> must have an <code>Actor</code>. The <code>Actor</code> contains all <code>Store</code> logic and handles the <code>Intent</code> that you pass to a <code>Store</code>.</p>"},{"location":"store/store/#middleware","title":"Middleware","text":"<p><code>Store</code> also supports <code>Middleware</code>. <code>Middleware</code> can be used as a spy - it receives all store events but cannot modify them.</p>"},{"location":"store/store/#interface","title":"Interface","text":"<pre><code>public interface Store&lt;in Intent : Any, out State : Any, out SideEffect : Any&gt; {\n\n    /** Returns Store state */\n    public val state: State\n\n    /** Returns Store states Flow */\n    public val states: StateFlow&lt;State&gt;\n\n    /** Returns Store side effects Flow */\n    public val sideEffects: Flow&lt;SideEffect&gt;\n\n    /**\n     * Initializes the Store\n     */\n    public fun init()\n\n    /**\n     * Accepts an Intent and passes it to the Actor\n     * Intent is also available inside the Middleware\n     */\n    public fun accept(intent: Intent)\n\n    /**\n     * Destroys the Store. Store cannot be used after it was destroyed\n     */\n    public fun destroy()\n}\n</code></pre>"},{"location":"store/store/#important-notes","title":"Important Notes","text":"<ul> <li>After calling <code>destroy()</code>, the Store cannot be used anymore.</li> <li>When a new State is emitted, it's available inside the Middleware.</li> <li>When a SideEffect is emitted, it's available inside the Middleware.</li> <li>Background work should be handled inside Actors using coroutines with the provided <code>CoroutineScope</code>.</li> </ul> <p>For more information, refer to the documentation for <code>Actor</code> and <code>Middleware</code>.</p>"}]}