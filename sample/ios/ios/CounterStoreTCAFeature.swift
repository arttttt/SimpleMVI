// Generated by SimpleMVI KSP TCAFeatureProcessor
// Do not edit manually

import ComposableArchitecture
import Shared
import Foundation


// MARK: - SideEffect Handler Protocol
protocol CounterStoreSideEffectHandler {
    func handle(_ effect: CounterStoreSideEffect) -> Effect<CounterFeature.Action>
}


// MARK: - Default Handler Implementation
struct DefaultCounterStoreSideEffectHandler: CounterStoreSideEffectHandler {
    func handle(_ effect: CounterStoreSideEffect) -> Effect<CounterFeature.Action>{
        switch effect {
        case is CounterStoreSideEffectCantResetCounter:
            return .none
        case is CounterStoreSideEffectCounterChanged:
            return .none
        case is CounterStoreSideEffectCounterReset:
            return .none
        default:
            return .none
        }
    }
}


// MARK: - TCA Dependency Registration
extension DependencyValues {
    var counterStore: CounterStore {
        get { self[CounterStoreKey.self] }
        set { self[CounterStoreKey.self] = newValue }
    }
}

private struct CounterStoreKey: DependencyKey {
    static let liveValue: CounterStore = {
        fatalError("CounterStore dependency not configured. Provide it via withDependencies.")
    }()
}

extension DependencyValues {
    var counterStoreSideEffectHandler: any CounterStoreSideEffectHandler {
        get { self[CounterStoreSideEffectHandlerKey.self] }
        set { self[CounterStoreSideEffectHandlerKey.self] = newValue }
    }
}
private struct CounterStoreSideEffectHandlerKey: DependencyKey {
    static let liveValue: any CounterStoreSideEffectHandler = DefaultCounterStoreSideEffectHandler()
}


// MARK: - TCA Feature
@Reducer
struct CounterFeature {
    
    @ObservableState
    struct State: Equatable {
        var counter: Int
        var _bridge = CounterStoreBridgeReducer.State()
        var _lifecycle: _CounterStoreLifecycle?
    }

    @CasePathable
    enum Action {
        case decrement
        case increment
        case reset

        case _bridge(CounterStoreBridgeReducer.Action)
        case _setLifecycle(_CounterStoreLifecycle?)
    }

    @Dependency(\.counterStore) var store
    @Dependency(\.counterStoreSideEffectHandler) var sideEffectHandler

    var body: some ReducerOf<Self> {
        Scope(state: \._bridge, action: \._bridge) {
            CounterStoreBridgeReducer()
        }
        
        Reduce { state, action in
            switch action {
            case .decrement:
                store.accept(intent: CounterStoreIntentDecrement())
                return .none
                
            case .increment:
                store.accept(intent: CounterStoreIntentIncrement())
                return .none
                
            case .reset:
                store.accept(intent: CounterStoreIntentReset())
                return .none
                
            case let ._bridge(.stateUpdated(domain)):
              state.apply(from: domain)
              return .none

            case let ._bridge(.sideEffect(sideEffect)):
              return sideEffectHandler.handle(sideEffect.wrapped)

            case ._bridge(.startObserving), ._bridge(.stopObserving):
              return .none
            case let ._setLifecycle(lifecycle):
                state._lifecycle = lifecycle
                return .none
                
            }
        }
    }
}


// MARK: - StoreState â†’ Feature.State Mapper
extension CounterFeature.State {
    mutating func apply(from domain: CounterStore.State) {
        self.counter = Int(domain.counter)
    }
}

@Reducer
struct CounterStoreBridgeReducer {
    
    struct State : Equatable {}
    
    @CasePathable
    enum Action : Equatable {
        case startObserving
        case stopObserving
        case stateUpdated(CounterStore.State)
        case sideEffect(StoreSideEffectWrapper<CounterStoreSideEffect>)
    }
    
    @Dependency(\.counterStore) var store
    
    var body: some Reducer<State, Action> {
        Reduce { state, action in
            switch action {
            case .startObserving:
                return observe()

            case .stopObserving:
              return .merge(
                .cancel(id: CancelID.state),
                .cancel(id: CancelID.sideEffects)
              )

            default:
              return .none
            }
        }
    }
}


// MARK: - Observable Bridge
extension CounterStoreBridgeReducer {
    
    private enum CancelID { case state, sideEffects }
    
    func observe() -> Effect<Action> {
        .merge(
            observeState(),
            observeSideEffects()
        )
    }
    
    private func observeState() -> Effect<Action> {
        .run { send in
            for try await state in asAsyncThrowingStream(CStateFlow<CounterStore.State>(source: store.states)) {
                await send(.stateUpdated(state))
            }
        }
        .cancellable(id: CancelID.state, cancelInFlight: false)
    }
    
    private func observeSideEffects() -> Effect<Action> {
        .run { send in
            for try await sideEffect in asAsyncThrowingStream(CFlow<CounterStoreSideEffect>(source: store.sideEffects)) {
                await send(.sideEffect(StoreSideEffectWrapper(wrapped: sideEffect)))
            }
        }
        .cancellable(id: CancelID.sideEffects, cancelInFlight: false)
    }
}


// MARK: - Factory
extension CounterFeature {
    
    static func from(
        store: CounterStore,
        withDependencies configureDependencies: @escaping (inout DependencyValues) -> Void = { _ in }
    ) -> StoreOf<Self> {
        let tcaStore = Store(
            initialState: State(
                counter: Int(store.state.counter),
                _bridge: CounterStoreBridgeReducer.State(),
                _lifecycle: nil
            )
        ) {
            CounterFeature()
        } withDependencies: { deps in
            deps.counterStore = store
            configureDependencies(&deps)
        }

        let lifecycle = _CounterStoreLifecycle(store: store) { action in
            await tcaStore.send(action)
        }
        Task { await tcaStore.send(._setLifecycle(lifecycle)) }

        return tcaStore
    }
}

// MARK: - Equatable
extension CounterFeature.State {
    static func == (lhs: Self, rhs: Self) -> Bool {
        return lhs.counter == rhs.counter
    }
}

// MARK: - Lifecycle Token
final class _CounterStoreLifecycle {
    private let store: CounterStore
    private var observerTask: Task<Void, Never>?

    init(store: CounterStore, send: @escaping (CounterFeature.Action) async -> Void) {
        self.store = store
        store.doInit()

        observerTask = Task {
            await withTaskGroup(of: Void.self) { group in
                group.addTask {
                    do {
                        for try await state in asAsyncThrowingStream(CStateFlow<CounterStore.State>(source: store.states)) {
                            await send(._bridge(.stateUpdated(state)))
                        }
                    } catch {}
                }

                group.addTask {
                    do {
                        for try await effect in asAsyncThrowingStream(CFlow<CounterStoreSideEffect>(source: store.sideEffects)) {
                            await send(._bridge(.sideEffect(StoreSideEffectWrapper(wrapped: effect))))
                        }
                    } catch {}
                }
            }
        }
    }

    deinit {
        observerTask?.cancel()
        store.destroy()
    }
}

