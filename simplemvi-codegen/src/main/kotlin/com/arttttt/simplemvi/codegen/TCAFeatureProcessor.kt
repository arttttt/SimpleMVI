package com.arttttt.simplemvi.codegen

import com.arttttt.simplemvi.annotations.TCAFeature
import com.google.devtools.ksp.KspExperimental
import com.google.devtools.ksp.getClassDeclarationByName
import com.google.devtools.ksp.processing.*
import com.google.devtools.ksp.symbol.*
import com.google.devtools.ksp.validate
import java.io.OutputStream

/**
 * KSP processor for generating TCA (The Composable Architecture) wrappers over SimpleMVI Store
 *
 * Generates Swift file with:
 * - SideEffectHandler protocol
 * - @Reducer struct for TCA integration
 * - Bridge reducer for subscribing to Store.states/sideEffects
 * - State mapper
 */
class TCAFeatureProcessor(
    private val codeGenerator: CodeGenerator,
    private val logger: KSPLogger,
) : SymbolProcessor {

    private companion object {
        const val STORE_FQN = "com.arttttt.simplemvi.store.Store"
    }

    override fun process(resolver: Resolver): List<KSAnnotated> {
        val annotated = resolver
            .getSymbolsWithAnnotation(TCAFeature::class.qualifiedName!!)
            .toList()

        val (valid, invalid) = annotated.partition { it.validate() }
        valid
            .filterIsInstance<KSClassDeclaration>()
            .forEach(::processStore)

        return invalid
    }

    @OptIn(KspExperimental::class)
    private fun processStore(storeClass: KSClassDeclaration) {
        val storeTypes = extractStoreTypes(storeClass) ?: run {
            logger.error("Cannot extract Store generic types from ${storeClass.qualifiedName?.asString()}", storeClass)
            return
        }

        val storeName = storeClass.simpleName.asString()
        val intentType = storeTypes.intentDeclaration
        val stateType = storeTypes.stateDeclaration
        val sideEffectType = storeTypes.sideEffectDeclaration

        val intentSubtypes = extractSealedSubtypes(intentType)

        val sideEffectSubtypes = extractSealedSubtypes(sideEffectType)

        val stateProperties = extractStateProperties(stateType)

        val swiftCode = generateSwiftCode(
            storeName = storeName,
            intentSubtypes = intentSubtypes,
            sideEffectSubtypes = sideEffectSubtypes,
            stateProperties = stateProperties
        )

        val fileName = "${storeName}TCAFeature"
        val dependencies = Dependencies(aggregating = false, storeClass.containingFile!!)

        codeGenerator.createNewFile(
            dependencies = dependencies,
            packageName = "",
            fileName = fileName,
            extensionName = "swift"
        ).use { output ->
            output.write(swiftCode.toByteArray())
        }
    }

    /**
     * Extracts Store<Intent, State, SideEffect> generic types
     */
    private fun extractStoreTypes(storeClass: KSClassDeclaration): StoreGenericTypes? {
        val storeInterface = storeClass.superTypes.firstOrNull { superType ->
            val declaration = superType.resolve().declaration
            declaration.qualifiedName?.asString() == STORE_FQN
        } ?: return null

        val typeArguments = storeInterface.resolve().arguments
        if (typeArguments.size != 3) return null

        val intentDecl = typeArguments[0].type?.resolve()?.declaration as? KSClassDeclaration ?: return null
        val stateDecl = typeArguments[1].type?.resolve()?.declaration as? KSClassDeclaration ?: return null
        val sideEffectDecl = typeArguments[2].type?.resolve()?.declaration as? KSClassDeclaration ?: return null

        return StoreGenericTypes(
            intentDeclaration = intentDecl,
            stateDeclaration = stateDecl,
            sideEffectDeclaration = sideEffectDecl
        )
    }

    /**
     * Extracts sealed interface subtypes via getSealedSubclasses()
     */
    private fun extractSealedSubtypes(declaration: KSClassDeclaration): List<String> {
        return declaration.getSealedSubclasses()
            .map { it.simpleName.asString() }
            .toList()
    }

    /**
     * Extracts properties from data class State
     */
    private fun extractStateProperties(stateDecl: KSClassDeclaration): List<StateProperty> {
        return stateDecl.getAllProperties()
            .filter { !it.simpleName.asString().startsWith("_") }
            .map { prop ->
                StateProperty(
                    name = prop.simpleName.asString(),
                    kotlinType = prop.type.resolve().declaration.simpleName.asString()
                )
            }
            .toList()
    }

    /**
     * Generates Swift code
     */
    private fun generateSwiftCode(
        storeName: String,
        intentSubtypes: List<String>,
        sideEffectSubtypes: List<String>,
        stateProperties: List<StateProperty>
    ): String {
        val featureName = storeName.removeSuffix("Store")

        return buildString {
            appendLine("// Generated by SimpleMVI KSP TCAFeatureProcessor")
            appendLine("// Do not edit manually")
            appendLine()
            appendLine("import ComposableArchitecture")
            appendLine("import Shared")
            appendLine("import Foundation")
            appendLine()
            appendLine()

            // SideEffect Handler Protocol
            appendLine("// MARK: - SideEffect Handler Protocol")
            appendLine("protocol ${storeName}SideEffectHandler {")
            appendLine("    func handle(_ effect: ${storeName}SideEffect) -> Effect<${featureName}Feature.Action>")
            appendLine("}")
            appendLine()
            appendLine()

            // Default Handler
            appendLine("// MARK: - Default Handler Implementation")
            appendLine("struct Default${storeName}SideEffectHandler: ${storeName}SideEffectHandler {")
            appendLine("    func handle(_ effect: ${storeName}SideEffect) -> Effect<${featureName}Feature.Action>{")
            appendLine("        switch effect {")
            for (subtype in sideEffectSubtypes) {
                appendLine("        case is ${storeName}SideEffect${subtype}:")
                appendLine("            return .none")
            }
            appendLine("        default:")
            appendLine("            return .none")
            appendLine("        }")
            appendLine("    }")
            appendLine("}")
            appendLine()
            appendLine()

            // TCA Dependency Registration
            appendLine("// MARK: - TCA Dependency Registration")
            appendLine("extension DependencyValues {")
            appendLine("    var ${storeName.toCamelCase()}: ${storeName} {")
            appendLine("        get { self[${storeName}Key.self] }")
            appendLine("        set { self[${storeName}Key.self] = newValue }")
            appendLine("    }")
            appendLine("}")
            appendLine()
            appendLine("private struct ${storeName}Key: DependencyKey {")
            appendLine("    static let liveValue: ${storeName} = {")
            appendLine("        fatalError(\"${storeName} dependency not configured. Provide it via withDependencies.\")")
            appendLine("    }()")
            appendLine("}")
            appendLine()
            appendLine("extension DependencyValues {")
            appendLine("    var ${storeName.toCamelCase()}SideEffectHandler: any ${storeName}SideEffectHandler {")
            appendLine("        get { self[${storeName}SideEffectHandlerKey.self] }")
            appendLine("        set { self[${storeName}SideEffectHandlerKey.self] = newValue }")
            appendLine("    }")
            appendLine("}")
            appendLine("private struct ${storeName}SideEffectHandlerKey: DependencyKey {")
            appendLine("    static let liveValue: any ${storeName}SideEffectHandler = Default${storeName}SideEffectHandler()")
            appendLine("}")
            appendLine()
            appendLine()

            // TCA Feature
            appendLine("// MARK: - TCA Feature")
            appendLine("@Reducer")
            appendLine("struct ${featureName}Feature {")
            appendLine("    ")
            appendLine("    @ObservableState")
            appendLine("    struct State: Equatable {")
            for (prop in stateProperties) {
                val swiftType = prop.kotlinType.toSwiftType()
                appendLine("        var ${prop.name}: $swiftType")
            }
            appendLine("        var _bridge = ${storeName}BridgeReducer.State()")
            appendLine("    }")
            appendLine()
            appendLine("    @CasePathable")
            appendLine("    enum Action: Equatable {")
            for (intent in intentSubtypes) {
                appendLine("        case ${intent.toCamelCase()}")
            }
            appendLine()
            appendLine("        case _bridge(${storeName}BridgeReducer.Action)")
            appendLine("    }")
            appendLine()
            appendLine("    @Dependency(\\.${storeName.toCamelCase()}) var store")
            appendLine("    @Dependency(\\.${storeName.toCamelCase()}SideEffectHandler) var sideEffectHandler")
            appendLine()
            appendLine("    var body: some ReducerOf<Self> {")
            appendLine("        Scope(state: \\._bridge, action: \\._bridge) {")
            appendLine("            ${storeName}BridgeReducer()")
            appendLine("        }")
            appendLine("        ")
            appendLine("        Reduce { state, action in")
            appendLine("            switch action {")
            for (intent in intentSubtypes) {
                appendLine("            case .${intent.toCamelCase()}:")
                appendLine("                store.accept(intent: ${storeName}Intent${intent}())")
                appendLine("                return .none")
                appendLine("                ")
            }
            appendLine("            case let ._bridge(.stateUpdated(domain)):")
            appendLine("              state.apply(from: domain)")
            appendLine("              return .none")
            appendLine()
            appendLine("            case let ._bridge(.sideEffect(sideEffect)):")
            appendLine("              return sideEffectHandler.handle(sideEffect.wrapped)")
            appendLine()
            appendLine("            case ._bridge(.startObserving), ._bridge(.stopObserving):")
            appendLine("              return .none")
            appendLine("            }")
            appendLine("        }")
            appendLine("    }")
            appendLine("}")
            appendLine()
            appendLine()

            // State Mapper
            appendLine("// MARK: - StoreState → Feature.State Mapper")
            appendLine("extension ${featureName}Feature.State {")
            appendLine("    mutating func apply(from domain: ${storeName}.State) {")
            for (prop in stateProperties) {
                val conversion = if (prop.kotlinType in listOf("Int", "Long")) {
                    "Int(domain.${prop.name})"
                } else {
                    "domain.${prop.name}"
                }
                appendLine("        self.${prop.name} = $conversion")
            }
            appendLine("    }")
            appendLine("}")
            appendLine()

            // Bridge Reducer
            appendLine("@Reducer")
            appendLine("struct ${storeName}BridgeReducer {")
            appendLine("    ")
            appendLine("    struct State : Equatable {}")
            appendLine("    ")
            appendLine("    @CasePathable")
            appendLine("    enum Action : Equatable {")
            appendLine("        case startObserving")
            appendLine("        case stopObserving")
            appendLine("        case stateUpdated(${storeName}.State)")
            appendLine("        case sideEffect(StoreSideEffectWrapper<${storeName}SideEffect>)")
            appendLine("    }")
            appendLine("    ")
            appendLine("    @Dependency(\\.${storeName.toCamelCase()}) var store")
            appendLine("    ")
            appendLine("    var body: some Reducer<State, Action> {")
            appendLine("        Reduce { state, action in")
            appendLine("            switch action {")
            appendLine("            case .startObserving:")
            appendLine("                return observe()")
            appendLine()
            appendLine("            case .stopObserving:")
            appendLine("              return .merge(")
            appendLine("                .cancel(id: CancelID.state),")
            appendLine("                .cancel(id: CancelID.sideEffects)")
            appendLine("              )")
            appendLine()
            appendLine("            default:")
            appendLine("              return .none")
            appendLine("            }")
            appendLine("        }")
            appendLine("    }")
            appendLine("}")
            appendLine()
            appendLine()

            // Observable Bridge
            appendLine("// MARK: - Observable Bridge")
            appendLine("extension ${storeName}BridgeReducer {")
            appendLine("    ")
            appendLine("    private enum CancelID { case state, sideEffects }")
            appendLine("    ")
            appendLine("    func observe() -> Effect<Action> {")
            appendLine("        .merge(")
            appendLine("            observeState(),")
            appendLine("            observeSideEffects()")
            appendLine("        )")
            appendLine("    }")
            appendLine("    ")
            appendLine("    private func observeState() -> Effect<Action> {")
            appendLine("        .run { send in")
            appendLine("            for try await state in asAsyncThrowingStream(CStateFlow<${storeName}.State>(source: store.states)) {")
            appendLine("                await send(.stateUpdated(state))")
            appendLine("            }")
            appendLine("        }")
            appendLine("        .cancellable(id: CancelID.state, cancelInFlight: false)")
            appendLine("    }")
            appendLine("    ")
            appendLine("    private func observeSideEffects() -> Effect<Action> {")
            appendLine("        .run { send in")
            appendLine("            for try await sideEffect in asAsyncThrowingStream(CFlow<${storeName}SideEffect>(source: store.sideEffects)) {")
            appendLine("                await send(.sideEffect(StoreSideEffectWrapper(wrapped: sideEffect)))")
            appendLine("            }")
            appendLine("        }")
            appendLine("        .cancellable(id: CancelID.sideEffects, cancelInFlight: false)")
            appendLine("    }")
            appendLine("}")
            appendLine()
            appendLine()

            // Factory Extension
            appendLine("// MARK: - Factory")
            appendLine("extension ${featureName}Feature {")
            appendLine("    ")
            appendLine("    static func from(")
            appendLine("        store: ${storeName},")
            appendLine("        withDependencies configureDependencies: @escaping (inout DependencyValues) -> Void = { _ in }")
            appendLine("    ) -> StoreOf<Self> {")
            appendLine("        Store(")
            appendLine("            initialState: State(")
            for (prop in stateProperties) {
                val conversion = if (prop.kotlinType in listOf("Int", "Long")) {
                    "Int(store.state.${prop.name})"
                } else {
                    "store.state.${prop.name}"
                }
                appendLine("                ${prop.name}: $conversion,")
            }
            appendLine("                _bridge: ${storeName}BridgeReducer.State()")
            appendLine("            )")
            appendLine("        ) {")
            appendLine("            ${featureName}Feature()")
            appendLine("        } withDependencies: { deps in")
            appendLine("            deps.${storeName.toCamelCase()} = store")
            appendLine("            configureDependencies(&deps)")
            appendLine("        }")
            appendLine("    }")
            appendLine("}")
        }
    }

    private data class StoreGenericTypes(
        val intentDeclaration: KSClassDeclaration,
        val stateDeclaration: KSClassDeclaration,
        val sideEffectDeclaration: KSClassDeclaration,
    )

    private data class StateProperty(
        val name: String,
        val kotlinType: String,
    )

    private fun String.toCamelCase(): String {
        return replaceFirstChar { it.lowercase() }
    }

    private fun String.toSwiftType(): String {
        return when (this) {
            "Int" -> "Int"
            "Long" -> "Int"
            "String" -> "String"
            "Boolean" -> "Bool"
            "Double" -> "Double"
            "Float" -> "Float"
            else -> this
        }
    }
}