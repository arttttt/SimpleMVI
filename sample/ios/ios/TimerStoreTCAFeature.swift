// Generated by SimpleMVI KSP TCAFeatureProcessor
// Do not edit manually

import ComposableArchitecture
import Shared
import Foundation


// MARK: - SideEffect Handler Protocol
protocol TimerStoreSideEffectHandler {
    func handle(_ effect: TimerStoreSideEffect) -> Effect<TimerFeature.Action>
}


// MARK: - Default Handler Implementation
struct DefaultTimerStoreSideEffectHandler: TimerStoreSideEffectHandler {
    func handle(_ effect: TimerStoreSideEffect) -> Effect<TimerFeature.Action>{
        switch effect {
        default:
            return .none
        }
    }
}


// MARK: - TCA Dependency Registration
extension DependencyValues {
    var timerStore: TimerStore {
        get { self[TimerStoreKey.self] }
        set { self[TimerStoreKey.self] = newValue }
    }
}

private struct TimerStoreKey: DependencyKey {
    static let liveValue: TimerStore = {
        fatalError("TimerStore dependency not configured. Provide it via withDependencies.")
    }()
}

extension DependencyValues {
    var timerStoreSideEffectHandler: any TimerStoreSideEffectHandler {
        get { self[TimerStoreSideEffectHandlerKey.self] }
        set { self[TimerStoreSideEffectHandlerKey.self] = newValue }
    }
}

private struct TimerStoreSideEffectHandlerKey: DependencyKey {
    static let liveValue: any TimerStoreSideEffectHandler = DefaultTimerStoreSideEffectHandler()
}

// MARK: - TCA Feature
@Reducer
struct TimerFeature {
    
    @ObservableState
    struct State: Equatable {
        var isTimerRunning: Bool
        var value: Int
    }

    @CasePathable
    enum Action {
        case resetTimer
        case startTimer
        case stopTimer

        case _stateUpdated(TimerStore.State)
        case _sideEffect(TimerStoreSideEffect)
    }

    @Dependency(\.timerStore) var store
    @Dependency(\.timerStoreSideEffectHandler) var sideEffectHandler

    var body: some ReducerOf<Self> {
        Reduce { state, action in
            switch action {
            case .resetTimer:
                store.accept(intent: TimerStoreIntentResetTimer())
                return .none
                
            case .startTimer:
                store.accept(intent: TimerStoreIntentStartTimer())
                return .none
                
            case .stopTimer:
                store.accept(intent: TimerStoreIntentStopTimer())
                return .none
                
            case let ._stateUpdated(domain):
                state.apply(from: domain)
                return .none

            case let ._sideEffect(sideEffect):
                return sideEffectHandler.handle(sideEffect)
            }
        }
    }
}


// MARK: - StoreState â†’ Feature.State Mapper
extension TimerFeature.State {
    mutating func apply(from domain: TimerStore.State) {
        self.isTimerRunning = domain.isTimerRunning
        self.value = Int(domain.value)
    }
}

// MARK: - Factory
extension TimerFeature {
    
    static func from(
        store: TimerStore,
        withDependencies configureDependencies: @escaping (inout DependencyValues) -> Void = { _ in }
    ) -> StoreOf<Self> {
        let lifecycle = _TimerStoreLifecycle(store: store)

        let tcaStore = Store(
            initialState: State(
                isTimerRunning: store.state.isTimerRunning,
                value: Int(store.state.value),
            )
        ) {
            TimerFeature()
        } withDependencies: { deps in
            deps.timerStore = store
            configureDependencies(&deps)
        }

        lifecycle.start { action in
            await tcaStore.send(action)
        }

        return tcaStore
    }
}

// MARK: - Equatable
extension TimerFeature.State {
    static func == (lhs: Self, rhs: Self) -> Bool {
        guard lhs.isTimerRunning == rhs.isTimerRunning else { return false }
        return lhs.value == rhs.value
    }
}

// MARK: - Lifecycle Token
final class _TimerStoreLifecycle {
    private let store: TimerStore
    private var observerTask: Task<Void, Never>?

    init(store: TimerStore) {
        self.store = store
        store.doInit()
    }

    func start(send: @escaping (TimerFeature.Action) async -> Void) {
        observerTask = Task {
            await withTaskGroup(of: Void.self) { group in
                group.addTask {
                    do {
                        for try await state in asAsyncThrowingStream(CStateFlow<TimerStore.State>(source: self.store.states)) {
                            await send(._stateUpdated(state))
                        }
                    } catch {}
                }

                group.addTask {
                    do {
                        for try await effect in asAsyncThrowingStream(CFlow<TimerStoreSideEffect>(source: self.store.sideEffects)) {
                            await send(._sideEffect(effect))
                        }
                    } catch {}
                }
            }
        }
    }

    deinit {
        observerTask?.cancel()
        store.destroy()
    }
}

