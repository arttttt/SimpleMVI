// Generated by SimpleMVI KSP TCAFeatureProcessor
// Do not edit manually

import ComposableArchitecture
import Shared
import Foundation


// MARK: - SideEffect Handler Protocol
protocol NotesStoreSideEffectHandler {
    func handle(_ effect: NotesStoreSideEffect) -> Effect<NotesFeature.Action>
}


// MARK: - Default Handler Implementation
struct DefaultNotesStoreSideEffectHandler: NotesStoreSideEffectHandler {
    func handle(_ effect: NotesStoreSideEffect) -> Effect<NotesFeature.Action>{
        switch effect {
        default:
            return .none
        }
    }
}


// MARK: - TCA Dependency Registration
extension DependencyValues {
    var notesStore: NotesStore {
        get { self[NotesStoreKey.self] }
        set { self[NotesStoreKey.self] = newValue }
    }
}

private struct NotesStoreKey: DependencyKey {
    static let liveValue: NotesStore = {
        fatalError("NotesStore dependency not configured. Provide it via withDependencies.")
    }()
}

extension DependencyValues {
    var notesStoreSideEffectHandler: any NotesStoreSideEffectHandler {
        get { self[NotesStoreSideEffectHandlerKey.self] }
        set { self[NotesStoreSideEffectHandlerKey.self] = newValue }
    }
}

private struct NotesStoreSideEffectHandlerKey: DependencyKey {
    static let liveValue: any NotesStoreSideEffectHandler = DefaultNotesStoreSideEffectHandler()
}

// MARK: - TCA Feature
@Reducer
struct NotesFeature {
    
    @ObservableState
    struct State: Equatable {
        var currentMessage: String
        var isInProgress: Bool
        var notes: [Note]
        var s1: KotlinArray<Note>
        var s2: Dictionary<String, Note>
        var s3: Set<Note>
        var s4: KotlinMutableSet<NSString>
        var s5: KotlinMutableDictionary<KotlinInt, Note>
        var s7: KotlinMutableDictionary<KotlinUInt, KotlinByte>
        var s8: KotlinMutableDictionary<KotlinLong, KotlinDouble>
        var s9: KotlinMutableDictionary<NSString, KotlinDouble>
        var s10: Set<String>
        var s11: KotlinMutableSet<NSString>
        var s12: MyEnum
        var s13: Int
    }

    @CasePathable
    enum Action {
        case addNote
        case currentMessageChanged(message: String)
        case loadNotes
        case removeNote(id: String)

        case _stateUpdated(NotesStore.State)
        case _sideEffect(NotesStoreSideEffect)
    }

    @Dependency(\.notesStore) var store
    @Dependency(\.notesStoreSideEffectHandler) var sideEffectHandler

    var body: some ReducerOf<Self> {
        Reduce { state, action in
            switch action {
            case .addNote:
                store.accept(intent: NotesStoreIntentAddNote())
                return .none
                
            case .currentMessageChanged(let message):
                store.accept(intent: NotesStoreIntentCurrentMessageChanged(message: message))
                return .none
                
            case .loadNotes:
                store.accept(intent: NotesStoreIntentLoadNotes())
                return .none
                
            case .removeNote(let id):
                store.accept(intent: NotesStoreIntentRemoveNote(id: id))
                return .none
                
            case let ._stateUpdated(domain):
                state.apply(from: domain)
                return .none

            case let ._sideEffect(sideEffect):
                return sideEffectHandler.handle(sideEffect)
            }
        }
    }
}


// MARK: - StoreState â†’ Feature.State Mapper
extension NotesFeature.State {
    mutating func apply(from domain: NotesStore.State) {
        self.currentMessage = domain.currentMessage
        self.isInProgress = domain.isInProgress
        self.notes = domain.notes
        self.s1 = domain.s1
        self.s2 = domain.s2
        self.s3 = domain.s3
        self.s4 = domain.s4
        self.s5 = domain.s5
        self.s7 = domain.s7
        self.s8 = domain.s8
        self.s9 = domain.s9
        self.s10 = domain.s10
        self.s11 = domain.s11
        self.s12 = domain.s12
        self.s13 = Int(domain.s13)
    }
}

// MARK: - Factory
extension NotesFeature {
    
    static func from(
        store: NotesStore,
        withDependencies configureDependencies: @escaping (inout DependencyValues) -> Void = { _ in }
    ) -> StoreOf<Self> {
        let lifecycle = _NotesStoreLifecycle(store: store)

        let tcaStore = Store(
            initialState: State(
                currentMessage: store.state.currentMessage,
                isInProgress: store.state.isInProgress,
                notes: store.state.notes,
                s1: store.state.s1,
                s2: store.state.s2,
                s3: store.state.s3,
                s4: store.state.s4,
                s5: store.state.s5,
                s7: store.state.s7,
                s8: store.state.s8,
                s9: store.state.s9,
                s10: store.state.s10,
                s11: store.state.s11,
                s12: store.state.s12,
                s13: Int(store.state.s13),
            )
        ) {
            NotesFeature()
        } withDependencies: { deps in
            deps.notesStore = store
            deps.notesStoreLifecycle = lifecycle
            configureDependencies(&deps)
        }

        lifecycle.start { action in
            await tcaStore.send(action)
        }

        return tcaStore
    }
}

// MARK: - Equatable
extension NotesFeature.State {
    static func == (lhs: Self, rhs: Self) -> Bool {
        guard lhs.currentMessage == rhs.currentMessage else { return false }
        guard lhs.isInProgress == rhs.isInProgress else { return false }
        guard lhs.notes == rhs.notes else { return false }
        guard lhs.s1 === rhs.s1 else { return false }
        guard lhs.s2 == rhs.s2 else { return false }
        guard lhs.s3 == rhs.s3 else { return false }
        guard lhs.s4 === rhs.s4 else { return false }
        guard lhs.s5 === rhs.s5 else { return false }
        guard lhs.s7 === rhs.s7 else { return false }
        guard lhs.s8 === rhs.s8 else { return false }
        guard lhs.s9 === rhs.s9 else { return false }
        guard lhs.s10 == rhs.s10 else { return false }
        guard lhs.s11 === rhs.s11 else { return false }
        guard lhs.s12 == rhs.s12 else { return false }
        return lhs.s13 == rhs.s13
    }
}

// MARK: - Lifecycle Token
final class _NotesStoreLifecycle {
    private let store: NotesStore
    private var observerTask: Task<Void, Never>?

    init(store: NotesStore) {
        self.store = store
        store.doInit()
    }

    func start(send: @escaping (NotesFeature.Action) async -> Void) {
        observerTask = Task {
            await withTaskGroup(of: Void.self) { group in
                group.addTask {
                    do {
                        for try await state in asAsyncThrowingStream(CStateFlow<NotesStore.State>(source: self.store.states)) {
                            await send(._stateUpdated(state))
                        }
                    } catch {}
                }

                group.addTask {
                    do {
                        for try await effect in asAsyncThrowingStream(CFlow<NotesStoreSideEffect>(source: self.store.sideEffects)) {
                            await send(._sideEffect(effect))
                        }
                    } catch {}
                }
            }
        }
    }

    deinit {
        observerTask?.cancel()
        store.destroy()
    }
}

