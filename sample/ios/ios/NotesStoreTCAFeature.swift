// Generated by SimpleMVI KSP TCAFeatureProcessor
// Do not edit manually

import ComposableArchitecture
import Shared
import Foundation


// MARK: - SideEffect Handler Protocol
protocol NotesStoreSideEffectHandler {
    func handle(_ effect: NotesStoreSideEffect) -> Effect<NotesFeature.Action>
}


// MARK: - Default Handler Implementation
struct DefaultNotesStoreSideEffectHandler: NotesStoreSideEffectHandler {
    func handle(_ effect: NotesStoreSideEffect) -> Effect<NotesFeature.Action>{
        switch effect {
        default:
            return .none
        }
    }
}


// MARK: - TCA Dependency Registration
extension DependencyValues {
    var notesStore: NotesStore {
        get { self[NotesStoreKey.self] }
        set { self[NotesStoreKey.self] = newValue }
    }
}

private struct NotesStoreKey: DependencyKey {
    static let liveValue: NotesStore = {
        fatalError("NotesStore dependency not configured. Provide it via withDependencies.")
    }()
}

extension DependencyValues {
    var notesStoreSideEffectHandler: any NotesStoreSideEffectHandler {
        get { self[NotesStoreSideEffectHandlerKey.self] }
        set { self[NotesStoreSideEffectHandlerKey.self] = newValue }
    }
}
private struct NotesStoreSideEffectHandlerKey: DependencyKey {
    static let liveValue: any NotesStoreSideEffectHandler = DefaultNotesStoreSideEffectHandler()
}


// MARK: - TCA Feature
@Reducer
struct NotesFeature {
    
    @ObservableState
    struct State: Equatable {
        var currentMessage: String
        var isInProgress: Bool
        var notes: List
        var _bridge = NotesStoreBridgeReducer.State()
    }

    @CasePathable
    enum Action: Equatable {
        case addNote
        case currentMessageChanged
        case loadNotes
        case removeNote

        case _bridge(NotesStoreBridgeReducer.Action)
    }

    @Dependency(\.notesStore) var store
    @Dependency(\.notesStoreSideEffectHandler) var sideEffectHandler

    var body: some ReducerOf<Self> {
        Scope(state: \._bridge, action: \._bridge) {
            NotesStoreBridgeReducer()
        }
        
        Reduce { state, action in
            switch action {
            case .addNote:
                store.accept(intent: NotesStoreIntentAddNote())
                return .none
                
            case .currentMessageChanged:
                store.accept(intent: NotesStoreIntentCurrentMessageChanged())
                return .none
                
            case .loadNotes:
                store.accept(intent: NotesStoreIntentLoadNotes())
                return .none
                
            case .removeNote:
                store.accept(intent: NotesStoreIntentRemoveNote())
                return .none
                
            case let ._bridge(.stateUpdated(domain)):
              state.apply(from: domain)
              return .none

            case let ._bridge(.sideEffect(sideEffect)):
              return sideEffectHandler.handle(sideEffect.wrapped)

            case ._bridge(.startObserving), ._bridge(.stopObserving):
              return .none
            }
        }
    }
}


// MARK: - StoreState â†’ Feature.State Mapper
extension NotesFeature.State {
    mutating func apply(from domain: NotesStore.State) {
        self.currentMessage = domain.currentMessage
        self.isInProgress = domain.isInProgress
        self.notes = domain.notes
    }
}

@Reducer
struct NotesStoreBridgeReducer {
    
    struct State : Equatable {}
    
    @CasePathable
    enum Action : Equatable {
        case startObserving
        case stopObserving
        case stateUpdated(NotesStore.State)
        case sideEffect(StoreSideEffectWrapper<NotesStoreSideEffect>)
    }
    
    @Dependency(\.notesStore) var store
    
    var body: some Reducer<State, Action> {
        Reduce { state, action in
            switch action {
            case .startObserving:
                return observe()

            case .stopObserving:
              return .merge(
                .cancel(id: CancelID.state),
                .cancel(id: CancelID.sideEffects)
              )

            default:
              return .none
            }
        }
    }
}


// MARK: - Observable Bridge
extension NotesStoreBridgeReducer {
    
    private enum CancelID { case state, sideEffects }
    
    func observe() -> Effect<Action> {
        .merge(
            observeState(),
            observeSideEffects()
        )
    }
    
    private func observeState() -> Effect<Action> {
        .run { send in
            for try await state in asAsyncThrowingStream(CStateFlow<NotesStore.State>(source: store.states)) {
                await send(.stateUpdated(state))
            }
        }
        .cancellable(id: CancelID.state, cancelInFlight: false)
    }
    
    private func observeSideEffects() -> Effect<Action> {
        .run { send in
            for try await sideEffect in asAsyncThrowingStream(CFlow<NotesStoreSideEffect>(source: store.sideEffects)) {
                await send(.sideEffect(StoreSideEffectWrapper(wrapped: sideEffect)))
            }
        }
        .cancellable(id: CancelID.sideEffects, cancelInFlight: false)
    }
}


// MARK: - Factory
extension NotesFeature {
    
    static func from(
        store: NotesStore,
        withDependencies configureDependencies: @escaping (inout DependencyValues) -> Void = { _ in }
    ) -> StoreOf<Self> {
        Store(
            initialState: State(
                currentMessage: store.state.currentMessage,
                isInProgress: store.state.isInProgress,
                notes: store.state.notes,
                _bridge: NotesStoreBridgeReducer.State()
            )
        ) {
            NotesFeature()
        } withDependencies: { deps in
            deps.notesStore = store
            configureDependencies(&deps)
        }
    }
}
